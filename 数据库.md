<center><h1>数据库系统原理-2020-期末复习提纲</h1></center>
<center><h3>制作：纪元 王汝婷</h3></center>
<center><h4>本提纲遵循CC-BY-NC-SA协议</h4>(署名-非商业性-相同方式共享)</center>



---

[toc]

---

# 第一章：介绍、本章目标





# 第二章:SQL语言介绍





# 第三章：SQL的技巧







# 第四章：关系数据库规范化理论

## 4.1 为什么要强调数据库设计的规范

> As we discussed in Chapter 1, databases arise from three sources: from existing data, from the development of new information systems, and from the redesign of existing databases.
>
> In this chapter and the next, we consider the design of databases from existing data, such as data from spreadsheets or extracts of existing databases. The premise(前提) of Chapters 4 and 5 is that you have received one or more tables of data from some source that are to be stored in a new database.
>
> The question is: Should this data be stored as is, or should it be transformed in some way before it is stored?
>
> For example, consider the two tables in the top part of Figure 3-1.
>
> These are the SKU_DATA and ORDER_ITEM tables extracted from the Cape Codd Outdoor Sports database as used in the database in Chapter 2.

正如我们在第一章中所讨论的，数据库因以下三个方面而产生: 现有数据、新信息系统的开发和现有数据库的重新设计。

在本章和下一章中，我们考虑依据现有数据来设计数据库，比如从电子表格获取数据，或从现有的数据库中提取数据。 第4章和第5章的前提是，您已经从某个数据来源接收到一个或多个数据表，这些数据表将存储在一个新的数据库中。

问题是: 这些数据是应该保持原样存储，还是应该在存储前，根据某种规则进行适当的转换？

例如图3-1上部的两个表 (ORDER_ITEM+SKU_DATA)。

这些是从 Cape Codd Outdoor Sports 数据库中提取的 SKU_DATA 和 ORDER_ITEM 表，如第2章中数据库中所使用的那样。

<img src="%E6%95%B0%E6%8D%AE%E5%BA%93.assets/image-20200630115906738.png" alt="image-20200630115906738" style="zoom:70%;" />

> You can design the new database to store this data as two separate tables, or you can join the tables together and design the database with just one table.
>
> Each alternative has advantages and disadvantages.When you make the decision to use one design, you obtain certain advantages at the expense of certain costs. The purpose of this chapter is to help you understand those advantages and costs. Such questions do not seem difficult, and you may be wondering why we need two chapters to answer them. In truth, even a single table can have surprising complexity. Consider, for example, the table in Figure 3-2,

您可以设计新的数据库，将这些数据存储为两个单独的表，或者您可以将这些表连接在一起，并使用一个表来设计数据库。

**每种选择都有其优点和缺点**。当你决定使用一种设计时，你会以牺牲一定的成本为代价获得一定的优势。 本章的目的是帮助你了解这些优点和成本。 这样的问题看起来并不难，你可能想知道为什么我们需要两章来回答它们。 事实上，即使是单个表也可能具有令人惊讶的复杂性。 例如，考虑图3-2中的表,

![image-20200630120210145](%E6%95%B0%E6%8D%AE%E5%BA%93.assets/image-20200630120210145.png)

> which shows sample data extracted from a corporate database. This simple table has three columns: the buyer’s name, the SKU of the products that the buyer purchases, and the names of the buyer’s college major(s). Buyers manage more than one SKU, and they can have multiple college majors.
>
> To understand why this is an odd(古怪的) table, suppose that Nancy Meyers is assigned a new SKU, say 101300. What addition should we make to this table? Clearly, we need to add a row for the new SKU, but if we add just one row, say the row ('Nancy Meyers', 101300, 'Art'), it will appear that she manages product 101300 as an Art major, but not as an Info Systems major. To avoid such an illogical state, we need to add two rows: ('Nancy Meyers', 101300, 'Art') and ('Nancy Meyers', 101300, 'Info Systems').

该表显示了从公司数据库中提取的样本数据。 这个简单的表有三列: 买家的姓名、买家购买产品的 SKU 以及买家的大学专业的名称。 单个买家可能拥有不止一个 SKU，他们也可能有多个大学专业。

为了理解为什么这是一个奇怪的表，假设 Nancy Meyers 被分配了一个新的 SKU，比如说101300。 我们应该在这张表里增加什么？ 很明显，我们需要为新的 SKU 增加一行，但是如果我们只增加一行，比如说这一行(Nancy Meyers，101300，Art) ，看起来她拥有产品101300，而且是艺术专业，而不是信息系统专业。 为了避免这种不合逻辑的状态，我们需要添加两行: (Nancy Meyers，101300，Art)和(Nancy Meyers，101300，Info Systems)。

> This is a strange requirement. Why should we have to add two rows of data simply to record the fact that a new SKU has been assigned to a buyer? Further, if we assign the product to Pete Hansen instead, we would only have to add one row, but if we assigned the product to a buyer who had four majors, we would have to add four new rows.
>
> The more one thinks about the table in Figure 3-2, the more strange it becomes. What changes should we make if SKU 101100 is assigned to Pete Hansen? What changes should we make if SKU 100100 is assigned to Nancy Meyers? What should we do if all the SKU values in Figure 3-2 are deleted? Later in this chapter, you will learn that these problems arise because this table has a problem called a ==multivalued dependency==. Even better, you will learn how to remove that problem. Tables can have many different patterns; some patterns are susceptible（可以接受的） to serious problems and other patterns are not. Before we can address this question, however, you need to learn some basic terms.

这是一个奇怪的要求。 为什么我们要为了 记录一个新增给买家的SKU 添加两行数据？ 此外，如果我们将产品分配给 Pete Hansen（只有一个专业），我们只需要添加一行，但是如果我们将产品分配给一个拥有四个主要专业的买家，我们就必须添加四个新行。

对图3-2中的表分析得越深，它就变得越奇怪。 如果 SKU 101100被分配给 Pete Hansen，我们应该做些什么改变？ 如果 SKU 100100被分配给 Nancy Meyers，我们应该做些什么改变？ 如果图3-2中的所有 SKU 值都被删除了，我们应该怎么做？ 在本章的后面，您将了解到这些问题的出现是因为这个表有一个称为==多值依赖==的问题。 更进一步的，你将学会如何解决这个问题。 表可以有许多不同的模式; 有些模式容易受到严重问题的影响，而其他模式则不会。 然而，在我们解决这个问题之前，需要学习一些基本术语。

## 4.2 关系模型术语

> Figure 3-3 lists the most important terms used by the relational model. By the time you finish Chapters 3 and 4, you should be able to define each of these terms and explain how each pertains to the design of relational databases. Use this list of terms as a check on your comprehension.

图3-3列出了关系模型使用的最重要的术语。 在你完成第3章和第4章的时候，你应该能够解释这些术语，并且解释它们与关系数据库设计之间的关系。 使用这个术语列表来检查你的理解。

<img src="%E6%95%B0%E6%8D%AE%E5%BA%93.assets/image-20200630204818717.png" alt="image-20200630204818717" style="zoom:67%;" />

### 关系

#### a. 关系简述

> a. Relations
>
> So far, we have used the terms table and relation interchangeably. In fact, a relation is a special case of a table. This means that all relations are tables, but not all tables are relations. Codd defined the characteristics of a relation in his 1970 paper that laid the foundation for the relational model. Those characteristics are summarized in Figure 3-4.

到目前为止，我们一直将表和关系混用。 事实上，**关系是表的一种特殊情况。 这意味着所有关系都是表，但并非所有表都是关系**。 Codd在他1970年的论文中定义了关系的特征，这篇论文奠定了关系模型的基础。 图3-4总结了这些特征。

<img src="%E6%95%B0%E6%8D%AE%E5%BA%93.assets/image-20200630205122914.png" alt="image-20200630205122914" style="zoom: 80%;" />

|             Characteristics of Relations              |          关系的特点          |
| :---------------------------------------------------: | :--------------------------: |
|           Rows contain data about an entity           |  行包含有关 单个实体 的数据  |
| Columns contain data about attributes of the entities |  列包含有关 实体属性 的数据  |
|     All entries in a column are of the same kind      | 列中的所有条目都属于同一种类 |
|             Each column has a unique name             |   每个列都有一个唯一的名称   |
|        Cells of the table hold a single value         |     表的单元格只有一个值     |
|        The order of the columns is unimportant        |       列的顺序并不重要       |
|         The order of the rows is unimportant          |       行的顺序并不重要       |
|             No two rows may be identical              |       没有两行是相同的       |

> By The Way In Figure 3-4 and in this discussion, we use the term entity to mean some dentifiable thing. A customer, a salesperson, an order, a part, and a lease are all examples of what we mean by an entity. When we introduce the entity-relationship model in Chapter 5, we will make the definition of entity more precise. For now, just think of an entity as some identifiable thing that users want to track.

在图3-4和本文的讨论中，我们使用术语“实体”来表示一些可识别的东西。 客户、销售人员、订单、部件和租约都是我们所说的实体的例子。 当我们在第5章介绍 ER 模型的时候，我们会使实体的定义更加精确。 现在，就把一个实体想象成 用户想要跟踪的 一些可识别的 东西。

#### B. 关系的特征

> b. Characteristics of Relations
>
> A relation has a specific definition, as shown in Figure 3-4, and for a table to be a relation, the criteria of this definition must be met.
>
> First, the rows of the table must store data about an entity and the columns of the table must store data about the characteristics of those entities.
>
> Next, the names of the columns are unique; no two columns in the same relation may have the same name. Further, in a relation, all of the values in a column are of the same kind. If, for example, the second column of the first row of a relation has FirstName, then the second column of every row in the relation has FirstName. This is an important requirement that is known as the ==domain integrity constraint==, where the ==term domain== means a grouping of data that meets a specific type definition. For example, FirstName would have a domain of names such as Albert, Bruce, Cathy, David, Edith, and so forth, and all values of FirstName must come from the names in that domain. The EMPLOYEE table shown in Figure 3-5 meets these criteria and is a relation.

关系有一个特定的定义，如图3-4所示，如果一个表是一个关系，必须满足关系的定义。

首先，表的行必须存储有关实体的数据，表的列必须存储有关这些实体属性的数据。

接下来，**列的名称是唯一的**; 同一关系中的任何两个列都不能具有相同的名称。 此外，在关系中，**列中的所有值都必须属于同一类型**。 例如，如果关系的第一行的第二列具有 FirstName，那么关系中每一行的第二列都必须具有 FirstName。 这是一个被称为==域完整性约束==的重要要求，其中 ==术语域== 意味着**满足特定类型定义的一组数据**。 例如，FirstName 的术语域包含Albert、 Bruce、 Cathy、 David、 Edith 等等，而 FirstName 的所有值都必须来自该术语域。 图3-5中显示的 EMPLOYEE 表符合这些标准，是一个关系。

<img src="%E6%95%B0%E6%8D%AE%E5%BA%93.assets/image-20200630205317699.png" alt="image-20200630205317699" style="zoom:67%;" />

> By The Way Columns in different relations may have the same name. In Chapter 2, for example, two relations had a column named SKU. When there is risk of confusion, we precede the column name with the relation name followed by a period(句号).Thus, the name of the SKU column in the SKU_DATA relation is SKU_DATA.SKU, and column C1 of relation R1 is named R1.C1. Because relation names are unique within a database and because column names are unique within a relation, the combination of relation name and column name uniquely identifies every column in the database.
>
> Each cell of a relation has only a single value or item; multiple entries are not allowed. The table in Figure 3-6 is not a relation because the Phone values of employees Caruthers and Bandalone store multiple phone numbers.

不同关系中的列可能具有相同的名称。 例如，在第二章中，两个关系都有一个名为 SKU 的列。 当存在混淆的风险时，我们采用**“关系名+句点+列名”**的模式进行区分。 因此，SKU_data 关系中， SKU 列的名称为 SKU_data.SKU。关系 R1的列 C1命名为 R1.C1。因为关系名称在数据库中是唯一的，并且列名在关系中是唯一的，所以**关系名称和列名称的组合能唯一地标识数据库中的每个列**。

**关系的每个单元格只有一个值或项**; 不允许有多个条目。 图3-6中的表格不是一个关系，因为雇员 Caruthers 和 Bandalone 的电话列存储了多个电话号码。

<img src="%E6%95%B0%E6%8D%AE%E5%BA%93.assets/image-20200630205401185.png" alt="image-20200630205401185" style="zoom:67%;" />

> In a relation, the order of the rows and the order of the columns are immaterial. No information can be carried by the ordering of rows or columns. The table in Figure 3-7 is not a relation because the entries for employees Caruthers and Caldera require a particular row arrangement. If the rows in this table were rearranged, we would not know which employee has the indicated Fax and Home numbers.

在关系中，**行的顺序和列的顺序是无关紧要的**。 按行或列的排列顺序不包含任何信息。 图3-7中的表格不是一个关系，因为雇员 Caruthers 和 Caldera 的条目需要一个特定的行排列。 如果重新排列此表中的行，我们将不知道哪个员工具有指定的传真号和主页号。

<img src="%E6%95%B0%E6%8D%AE%E5%BA%93.assets/image-20200630205502026.png" alt="image-20200630205502026" style="zoom: 80%;" />

> Finally, according to the last characteristic in Figure 3-4, for a table to be a relation, no two rows can be identical. As you learned in Chapter 2, some SQL statements do produce tables with duplicate rows. In such cases, you can use the DISTINCT keyword to force uniqueness. Such row duplication only occurs as a result of SQL manipulation. Tables that you design to be stored in the database should never contain duplicate rows.
>
> By The Way Do not fall into a common trap.
>
> Even though every cell of a relation must have a single value, this does not mean that all values must have the same length. The table in Figure 3-8 is a relation even though the length of the Comment column varies from row to row. It is a relation because, even though the comments have different lengths, there is only one comment per cell.

最后，根据图3-4中的最后一个特征，**对于一个关系表，没有两行是相同的**。 正如在第2章中了解到的，一些 SQL 语句确实会生成具有重复行的表。 在这种情况下，可以使用 DISTINCT 关键字强制显示单一条目。 只有在 SQL 操作的结果中才会出现这种行重复。 设计存储在数据库中的表不应该包含重复的行。
顺便说一句，不要掉进一个普通的陷阱。
即使关系的每个单元格必须具有单个值，但这**并不意味着所有值必须具有相同的长度**。 图3-8中的表是一个关系，尽管 Comment 列的长度因行而异。 此表仍然是一个关系，因为尽管注释的长度不同，但是每个单元格只有一个注释。

<img src="%E6%95%B0%E6%8D%AE%E5%BA%93.assets/image-20200630205620238.png" alt="image-20200630205620238" style="zoom:80%;" />

#### C. 可替代的词汇

> c. Alternative Terminology
>
> As defined by Codd, the columns of a relation are called ==attributes== and the rows of a relation are called ==tuples== (rhymes with “couples”). Most practitioners, however, do not use these academic-sounding terms and instead use the terms ==column== and ==row==.
>
> Also, even though a table is not necessarily a relation, most practitioners mean relation when they say table. Thus, in most conversations the terms relation and table are synonymous（同义的）. In fact, for the rest of this book table and relation will be used synonymously.
>
> Additionally, a third set of terminology also is used.
>
> Some practitioners use the ==terms file==, ==field==, and ==record== for the terms table, column, and row, respectively. These terms arose from traditional data processing and are common in connection with legacy systems.
>
> Sometimes, people mix and match these terms. You might hear someone say, for example, that a relation has a certain column and contains 47 records. These three sets of terms are summarized in Figure 3-9.

在Codd 的定义中，关系的列称为==属性==，关系的行称为==元组==(与“ couples”押韵)。 然而，大多数用户并不使用这些听上去学术味浓重的词汇，而是使用==列==和==行==代替。

此外，即使表不一定是关系，大多数人在说”表“时，其实就是在说“关系”。 因此，在大多数交流中，关系和表是同义词。 事实上，对于本书的其余部分，表和关系将被当作同义词使用。
此外，还使用了第三套术语。
一些从业人员分别用==档案==、==字段==和==记录==来称呼表、列和行。 这些术语起源于传统的数据处理，在遗留系统中很常见。
有时，人们混合搭配这些术语。 例如，你可能听到有人说，一个关系有一个特定的列，包含47条记录。 图3-9总结了这三组术语。

![image-20200630205714706](%E6%95%B0%E6%8D%AE%E5%BA%93.assets/image-20200630205714706.png)

|          |           |        |
| :------: | :-------: | :----: |
|  Table   |  Column   |  Row   |
|    表    |    行     |   列   |
| Relation | Attribute | Tuple  |
|   关系   |   属性    |  元组  |
|   File   |   Field   | Record |
|   档案   |   字段    |  记录  |

### 函数依赖

> a. Functional Dependencies
>
> Functional dependencies are the heart of the database design process, and it is vital（至关重要的） for you to understand them. We first explain the concept in general terms and then examine two examples. We begin with a short excursion（远足） into the world of algebra（代数）.
> Suppose you are buying boxes of cookies and someone tells you that each box costs \$ 5.00. With this fact, you can compute the cost of several boxes with the formula: 
>
> CookieCost = NumberOfBoxes × $ 5

函数依赖是数据库设计过程的核心，理解它们是至关重要的。 我们首先用一般的术语解释这个概念，然后考察两个例子。 我们从代数世界的一个短途旅行开始。
假设你正在买一盒饼干，有人告诉你每盒要5美元。 有了这个事实，您可以使用以下公式计算总成本: 

饼干总价格 = 购买盒数 × \$5 

> A more general way to express the relationship between CookieCost and NumberOfBoxes is to say that CookieCost depends on NumberOfBoxes. Such a statement tells us the character of the relationship between CookieCost and NumberOfBoxes, even though it doesn't give us the formula. More formally, we can say that CookieCost is functionally dependent on NumberOfBoxes. Such a statement can be written as:
>
> NumberOfBoxes →CookieCost 

表达 CookieCost 和 NumberOfBoxes 之间关系的更一般的方式是说 CookieCost 取决于 NumberOfBoxes。 这样的语句告诉我们 CookieCost 和 NumberOfBoxes 之间关系的性质，尽管它没有给出公式。 更正式地说，我们可以说CookieCost 在函数上依赖于 NumberOfBoxes。 这样的语句可以写成:

购买盒数 → 饼干总价格​

> This expression can be read as “NumberOfBoxes determines CookieCost.” 
>
> The variable on the left, here NumberOfBoxes, is called the ==determinant==. Using another formula, we can compute the extended price of a part order by multiplying the quantity of the item times its unit price, or: 
>
> ExtendedPrice = Quantity × UnitPrice
>
> In this case, we say that ExtendedPrice is ==functionally dependent== on Quantity and UnitPrice, or: 
>
> (Quantity, UnitPrice) → ExtendedPrice

这个表达式可以理解为“ 购买的盒数决定了饼干总价” 

在左边的变量（购买盒数），被称为==决定因素==。我们可以通过求物品数量和物品单价的乘积来计算部分订单的扩展价格。即： 

扩展价格 = 数量 × 单价

在这种情况下，我们也可以说，扩展价格==函数依赖==于购买数量和商品单价，即:

 (数量，单价)→扩展价格


> Here the determinant is the composite (Quantity, UnitPrice). Functional Dependencies That Are Not Equations In general, a functional dependency exists when the value of one or more attributes determines the value of another attribute. Many functional dependencies exist that do not involve equations.
>
> Consider an example. Suppose you know that a sack contains either red, blue, or yellow objects.
> Further, suppose you know that the red objects weigh 5 pounds, the blue objects weigh 5 pounds, and the yellow objects weigh 7 pounds. If a friend looks into the sack, sees an object, and tells you the color of the object, you can tell her the weight of the object. We can formalize this as:
> ObjectColor→ Weight

这里的决定因素是组合(数量，单价)。 一般来说，当一个或多个属性的值决定另一个属性的值时，就存在==函数依赖==。 **许多函数依赖的存在，并不涉及方程**。
举个例子，假设你知道一个袋子里装着红色、蓝色或者黄色的物体。
再进一步，假设你知道红色物体重5磅，蓝色物体重5磅，黄色物体重7磅。 如果一个朋友看了一眼袋子，然后告诉你物体的颜色，你可以告诉她物体的重量。 我们可以将其形式化为:

物体颜色 → 重量

> Thus, we can say that Weight is ==functionally dependent== on ObjectColor and that ObjectColor determines Weight. The relationship here does not involve an equation, but the ==functional dependency== holds. Given a value for ObjectColor, you can determine the object's weight.
>
> If we also know that the red objects are balls, the blue objects are cubes（立方体）, and the yellow objects are cubes, we can also say:
>
> ObjectColor→ Shape
>
> Thus, ObjectColor determines Shape. We can put these two together to state: 
>
> ObjectColor →(Weight, Shape)
>
> Thus, ObjectColor determines Weight and Shape. Another way to represent these facts is to put them into a table:

因此，我们可以说重量==函数依赖==于对象颜色，而物体颜色决定重量。 这里的关系不涉及方程式，但是==函数依赖==是成立的。 给定物体的颜色，就可以确定物体的重量。

如果我们还知道红色的物体是球，蓝色的物体是立方体 ，黄色的物体是立方体，我们也可以说: 

ObjectColor → Shape

因此，物体颜色决定形状。 我们可以把这两者放在一起来表示: 

物体颜色→(重量，形状) 

因此，物体颜色同时决定重量和形状。 另一种表示这些事实的方法是，把它们放到一张表中:

![image-20200630225835126](%E6%95%B0%E6%8D%AE%E5%BA%93.assets/image-20200630225835126.png)

> This table meets all of the conditions listed in Figure 3-4, and therefore it is a relation.
>
> You may be thinking that we performed a trick or sleight of hand（表演了一个魔术或者戏法） to arrive at this relation, but, in truth, the only reason for having relations is to store instances of functional dependencies. If there were a formula by which we could take ObjectColor and somehow compute Weight and Shape, then we would not need the table. We would just make the computation.
>
> Similarly, if there were a formula by which we could take EmployeeNumber and compute EmployeeName and HireDate, then we would not need an EMPLOYEE relation.
>
> However, because there is no such formula, we must store the combinations of EmployeeNumber, EmployeeName, and HireDate in the rows of a relation. Composite Functional Dependencies The determinant of a functional dependency can consist of more than one attribute. For example, a grade in a class is determined by both the student and the class,or: 
>
> (StudentNumber, ClassNumber) → Grade
>
> In this case, the determinant is called a ==composite determinant==. Notice that both the student and the class are needed to determine the grade.
>
> In general, if (A, B) → C, then neither A nor B will determine C by itself. However, if A→ (B, C), then it is true that A → B and A→C. Work through examples of your own for both of these cases so that you understand why this is true.

此表满足图3-4中列出的所有条件，因此它是一个关系。

你可能会认为我们为了得到这个关系而玩了一个小把戏，但实际上，拥有关系的唯一原因在于存储函数依赖的实例。 如果有一个公式，我们可以采取对象颜色，并以某种方式计算重量和形状，那么我们就不需要表。 我们只需要进行计算。

类似地，如果有一个公式可以用来获取 EmployeeNumber 并计算 EmployeeName 和 HireDate，那么我们就不需要建立 EMPLOYEE 关系。

但是，由于没有这样的公式，我们必须将 EmployeeNumber、 EmployeeName 和 HireDate 的组合存储在关系的行中。 复合函数依赖函数依赖的行列式可以由多个属性组成。 例如，一个班的成绩是由学生和该班共同决定的，或者: 

(学生数，班级数)→年级（人数）

在这种情况下，行列式称为==组合决定因素==。 注意，学生和班级共同决定年级（人数）。

一般来说，如果(a，b)→ c，那么 a 和 b 都不能自己决定 c。 然而，如果 a →(b，c) ，那么 a → b 和 a → c 就是正确的，通过你自己举例子来模拟这两种情况，你就会明白为什么这是正确的。

> To fix the idea of ==functional dependency== in your mind, consider what ==functional dependencies== exist in the SKU_DATA and ORDER_ITEM tables in Figure 3-1. To find functional dependencies in a table, we must ask “Does any column determine the value of another column?” For example, consider the values of the SKU_DATA table in Figure 3-1:

为了解决==函数依赖==的问题，请考虑图3-1中的 SKU_data 和 ORDER_item 表中存在哪些==函数依赖==。 要查找表中的函数依赖关系，就是寻找“是否有任何列决定另一列的值? ” 例如，考虑图3-1中 SKU_data 表的值:

![image-20200630231319736](%E6%95%B0%E6%8D%AE%E5%BA%93.assets/image-20200630231319736.png)

> Consider the last two columns. If we know the value of Department, can we determine a unique value of Buyer? No, we cannot, because a Department may have more than one Buyer. In these sample data, 'Water Sports' is associated with Pete Hansen and Nancy Meyers.
>
> Therefore, Department does not ==functionally determine== Buyer. What about the reverse? Does Buyer determine Department? In every row, for a given value of Buyer, do we find the same value of Department? Every time Jerry Martin appears, for example, is he paired with the same department? The answer is yes.
>
> Further, every time Cindy Lo appears, she is paired with the same department.
>
> The same is true for the other buyers. Therefore, assuming that these data are representative, Buyer does determine Department, and we can write: Buyer → Department

考虑一下最后两列。 如果我们知道具体的部门，我们可以确定一个唯一的购买者吗？ 并不能，因为一个部门可能有一个以上的买家。 在这些样本数据中，“水上运动”与皮特 · 汉森和南希 · 迈耶斯都有关系。

因此，部门并不==函数依赖==于买方。 反过来呢？ 买方是否能决定部门？ 在每一行中，对于一个给定的买方，我们能否保证每个部门都是相同的？ 例如，每次杰瑞 · 马丁出现时，他是否都与同一个部门对应？ 答案是肯定的。

此外，每次辛迪 · 罗出现，她都会和同一个部门相配对。

其他买家也是如此。 因此，假设这些数据具有代表性，买方可以确定部门，我们可以写做: 

买方→部门

> Does Buyer determine any other column? If we know the value of Buyer, do we know the value of SKU? No, we do not, because a given buyer has many SKUs assigned to him or her. Does Buyer determine SKU_Description? No, because a given value of Buyer occurs with many values of SKU_Description. By the way, As stated, for the Buyer→Department ==functional dependency==, a Buyer is paired with one and only one value of Department. Notice that a buyer can appear more than once in the table, but, if so, that buyer is always paired with the same department. This is true for all functional dependencies. If A→B, then each value of A will be paired with one and only one value of B.
>
> A particular value of A may appear more than once in the relation, but, if so, it is always paired with the same value of B.
>
> Note, too, that the reverse is not necessarily true. If A→B, then a value of B may be paired with many values of A.
>
> What about the other columns? It turns out that if we know the value of SKU, we also know the values of all of the other columns. In other words: 
>
> SKU→SKU_Description
>
> because a given value of SKU will have just one value of SKU_Description. Next, 
>
> SKU→ Department
>
> because a given value of SKU will have just one value of Department. And, finally, 
>
> SKU → Buyer
>
> because a given value of SKU will have just one value of Buyer. We can combine these three statements as:
>
> SKU→ (SKU_Description, Department, Buyer) 
>
> For the same reasons, SKU_Description determines all of the other columns, and we can write: 
>
> SKU_Description → (SKU, Department, Buyer) 
>
> In summary, the functional dependencies in the SKU_DATA table are: 
>
> SKU →(SKU_Description, Department, Buyer) 
>
> SKU_Description →(SKU, Department, Buyer) 
>
> Buyer →Department 

买方是否能够确定其他列呢？ 如果我们知道具体的买家，我们能确定SKU 吗？不能，因为对于一个给定的买家，能找到到多个不同的sku。 买方是否决定 SKU_Description？ 不，因为给定的 Buyer 对应许多 SKU_description。 顺便说一下，如前所述，对于买方→部门的函数==函数依赖==，买方与部门有且只有一个值配对（一一对应）。 注意，同一个买家可以在表中出现不止一次，但是，如果是这样，必须保证这个买家总是与同一个部门配对。 这对于所有函数依赖都是必要的。 如果 a → b，那么每个 a 都将与 b 的唯一值配对。

特定值 a 可能在关系中出现不止一次，但是，如果是这样，它每次出现必须对应唯一的 b 。同时还要注意，这个规则反过来也不一定正确。 如果 a → b，那么 b 的值可能对应不止一个 a。

其他的列呢？ 只要我们知道 SKU 的值，我们也就知道了所有其他列的值。 换句话说: SKU → SKU_Description，因为给定的 SKU 只有唯一的 SKU 描述。 接下来，SKU → Department，因为给定的 SKU 对应唯一的 Department 。 最后，SKU → Buyer，因为给定的 SKU 对应唯一的 Buyer 。 我们可以将以下三种说法结合起来:

SKU →(SKU_description，Department，Buyer)

出于同样的原因，SKU_description 决定了所有其他列，我们可以写作: SKU_description →(SKU，Department，Buyer) 总的来说，SKU_data 表中的函数依赖是: 

SKU →(SKU_description，Department，Buyer) 

SKU_description →(SKU，Department，Buyer) 

Buyer → Department 

> By the way, You cannot always determine functional dependencies from sample data. You may not have any sample data, or you may have just a few rows that are not representative of all of the data conditions. In such cases, you must ask the users who are experts in the application that creates the data.
> For the SKU_DATA table, you would ask questions such as, “Is a Buyer always associated with the same Department?” and “Can a Department have more than one Buyer?” In most cases, answers to such questions are more reliable than sample data. When in doubt, trust the users.
> Functional Dependencies in the ORDER_ITEM Table Now consider the ORDER_ITEM table in Figure 3-1. For convenience, here is a copy of the data in that table:

顺便说一下，不能总是从样本数据中决定函数依赖。 您可能没有任何示例数据，或者只有几行，这些数据不能代表所有数据。 在这种情况下，您必须询问相关领域的专家。

对于 SKU_data 表，您可以问这样的问题，“买方是否总是与同一个部门相关联?” 及 “一个部门可否有多于一名买家? ” 在大多数情况下，这些问题的答案比样本数据更可靠。 如果有疑问，始终相信专家。

现在考虑图3-1中的 ORDER_item 表中的函数依赖关系。 为了方便起见，下面给出该表中数据的副本:

![image-20200630231438818](%E6%95%B0%E6%8D%AE%E5%BA%93.assets/image-20200630231438818.png)

> What are the functional dependencies in this table?
>
> Start on the left. Does OrderNumber determine another column? It does not determine SKU because several SKUs are associated with a given order. For the same reasons, it does not determine Quantity, Price, or ExtendedPrice.
>
> What about SKU? SKU does not determine OrderNumber because several OrderNumbers are associated with a given SKU. It does not determine Quantity or ExtendedPrice for the same reason.
>
> What about SKU and Price? From this data, it does appear that 
>
> SKU → Price 
>
> but that might not be true in general. In fact, we know that prices can change after an order has been processed. Further, an order might have special pricing due to a sale or promotion. To keep an accurate record of what the customer actually paid, we need to associate a particular SKU price with a particular order. Thus: 
>
> (OrderNumber, SKU) → Price 

这个表中的函数依赖关系是什么？

从这个表的左边开始看。 OrderNumber 是否决定另一列？ 它不能决定 SKU，因为多个 SKU 都与给定的订单相关联。 出于同样的原因，它不确定数量、价格或扩展价格。

Sku 怎么样？ Sku 不能决定 OrderNumber，因为多个 OrderNumber 与给定的 SKU 相关联。 出于同样的原因，它不确定 Quantity 或 ExtendedPrice。

Sku 和 单价 怎么样？ 从这个数据来看，似乎

SKU → Price 

但这可能一般事实。 实际上我们知道，订单处理后价格会发生变化。 此外，由于销售或促销，订单可能有特殊的价格。 为了保持客户实际支付的准确记录，我们需要将特定 SKU 价格与特定订单关联起来。 因此: 

(OrderNumber，SKU)→Price

> Considering the other columns, Quantity, Price, and ExtendedPrice do not determine anything else. You can decide this by looking at the sample data. You can reinforce this conclusion by thinking about the nature of sales. Would a Quantity of 2 ever determine an OrderNumber or a SKU? This makes no sense. At the grocery store, if I tell you I bought two of something, you have no reason to conclude that my OrderNumber was 1010022203466 or that I bought carrots. Quantity does not determine OrderNumber or SKU. Similarly, if I tell you that the price of an item was $3.99, there is no logical way to conclude what my OrderNumber was or that I bought a jar of green olives. Thus, Price does not determine OrderNumber or SKU. Similar comments pertain to ExtendedPrice. It turns out that no single column is a determinant in the ORDER_ITEM table. What about pairs of columns? We already know that  
>
> (OrderNumber, SKU) → Price   
>
> Examining the data, (OrderNumber, SKU) determines the other two columns as well. Thus:  
>
> (OrderNumber, SKU) → (Quantity, Price, ExtendedPrice)   
>
> This functional dependency makes sense. It means that given a particular order and a particular item on that order, there is only one quantity, one price, and one extended price. Notice, too, that because ExtendedPrice is computed from the formula 
>
> ExtendedPrice = (Quantity * Price) 
>
> we have:   
>
> (Quantity, Price) →ExtendedPrice   
>
> In summary, the functional dependencies in ORDER_ITEM are:   
>
> (OrderNumber, SKU) →(Quantity, Price, ExtendedPrice)  
>
> (Quantity, Price) → ExtendedPrice 

考虑到其他列，数量、价格和扩展价格不能决定任何其他内容。 您可以通过查看示例数据来确定这一点。 你可以通过思考销售的本质来强化这个结论。 商品数量2是否决定了一个订单号或一个 SKU？ 这毫无意义。 在杂货店，如果我告诉你我买了两样东西，你没有理由得出结论说我的订单号是1010022203466或者我买了胡萝卜。 数量不能决定订单号或 SKU。 类似地，如果我告诉你一件商品的价格是3.99美元，那么就没有合乎逻辑的方法来推断：我的订单号是多少，或者我买了一罐绿橄榄。 因此，价格不能决定订单号或 SKU。 类似的注释也适用于 ExtendedPrice。 结果表明，order_item 表中没有一个列是==决定因素==。 那么对于成对的列呢？ 我们已经知道

(OrderNumber，SKU)→ Price 

检查数据，(OrderNumber，SKU)也可以同时确定其他两列。 因此:(OrderNumber，SKU)→(Quantity，Price，ExtendedPrice)这个函数依赖是有意义的。 这意味着，给定一个特定的订单号和该订单上的特定项目，就可以确定数量、单价和扩展价格。 还要注意，因为 ExtendedPrice 是从公式 ExtendedPrice = (Quantity * Price)中计算出来的: 

(Quantity，Price)→ ExtendedPrice 

总之，ORDER_item 中的函数依赖关系是: 

(OrderNumber, SKU) →(Quantity, Price, ExtendedPrice)  

 (Quantity, Price) → ExtendedPrice 

> No single skill is more important for designing databases than the ability to identify functional dependencies. Make sure you understand the material in this section. You must understand functional dependencies and be able to work with them.
> When Are Determinant Values Unique? In the previous section, you may have noticed an irregularity(不规则，无规律 ).
> Sometimes the ==determinants== of a functional dependency are unique in a relation, and sometimes they are not.
> Consider the SKU_DATA relation, with determinants SKU, SKU_Description, and Buyer. In SKU_DATA, the values of both SKU and SKU_Description are unique in the table.
> For example, the SKU value 100100 appears just once. Similarly, the SKU_Description value 'Half-dome Tent' occurs just once. From this, it is tempting to conclude that values of determinants are always unique in a relation.
> However, this is not true. For example, Buyer is a determinant, but it is not unique in SKU_DATA. The buyer 'Cindy Lo' appears in two different rows. In fact, for these sample data all of the buyers occur in two different rows.

对于设计数据库来说，没有哪种技能比识别函数依赖关系的能力更重要。 确保你理解了这一部分的内容。 你必须了解函数依赖关系，并能够使用它们。

什么时候行列式值是唯一的? 在上一节中，您可能已经注意到一个不规则的现象：有时函数依赖的==决定因素==在关系中是唯一的，有时则不是。

考虑 SKU_data 关系，包括行列式 SKU、 SKU_Description和Buyer。 在 SKU_data 中，表中 SKU 和 SKU_description 的值都是唯一的。例如，SKU 值100100只出现一次。 类似地，SKU_Description“半圆顶帐篷”只出现一次。 由此，我们很容易得出这样的结论: ==决定因素==的值在一种关系中总是唯一的。

然而，事实并非如此。 例如，Buyer 是一个决定因素，但它在 SKU_data 中不是唯一的。 买家’辛迪罗’出现在了两个不同的行中。 实际上，对于这些示例数据，所有买家都出现在两个不同的行中。

> In truth, a determinant is unique in a relation only if it determines every other column in the relation. For the SKU_DATA relation, SKU determines all of the other columns.
>
> Similarly, SKU_Description determines all of the other columns. Hence, they both are unique.
>
> Buyer, however, only determines the Department column. It does not determine SKU or SKU_Description. The determinants in ORDER_ITEM are (OrderNumber, SKU) and (Quantity, Price). Because (OrderNumber, SKU) determines all of the other columns, it will be unique in the relation. The composite (Quantity and Price) only determines ExtendedPrice. Therefore, it will not be unique in the relation. This fact means that you cannot find the determinants of all functional dependencies simply by looking for unique values. Some of the determinants will be unique, but some will not be. Instead, to determine if column A determines column B, look at the data and ask, “Every time a value of column A appears, is it matched with the same value of Column B?” If so, it can be a determinant of B. Again, however, sample data can be incomplete, so the best strategies are to think about the nature of the business activity from which the data arise and to ask the users.

事实上，**一个==决定因素==当且仅当它能决定关系中的每一列时，它在一个关系中唯一**。 对于 SKU_data 关系，SKU 确定所有其他列。（因此SKU唯一）

同样，SKU_description 决定了所有其他列，因此它们都是唯一的。

然而，买方只确定部门一栏。 它不确定 SKU 或 SKU_Description。 Order_item 中的决定因素是(OrderNumber，SKU)和(Quantity，Price)。 因为(OrderNumber，SKU)确定所有其他列，所以它在关系中是唯一的。 组合(Quantity and Price)仅确定 ExtendedPrice。 因此，再此关系中它并不唯一。 这意味着：**不能仅仅通过寻找唯一的值，来找到所有==函数依赖关系==的==决定因素==**。 一些决定因素将是独一无二的，但一些不会。 相反，要确定列 a 是否决定列 b，请查看数据并询问: “每次出现列 a 的值时，它是否与列 b 的相同值相匹配? ” 如果是这样的话，它可能是 b 的决定因素，然而，样本数据可能是不完整的，所以最好的策略是考虑数据产生的业务活动的性质，并询问用户。

### 键

> There are candidate keys, composite keys, primary keys, surrogate keys, and foreign keys. In this section, we will define each of these types of keys. Because key definitions rely on the concept of functional dependency, make sure you understand that concept before reading on. In general, a key is a combination of one or more columns that is used to identify particular rows in a relation. Keys that have two or more columns are called composite keys.

键主要有候选键、组合键、主键、代理键和外键。 在本节中，我们将定义这些键的每种类型。 因为键的定义依赖于函数依赖的概念，所以在继续阅读之前一定要理解这个概念。 通常，键是用于标识关系中特定行的一个或多个列的组合。 具有两个或多个列的键称为复合键。

#### 候选键

> Candidate Keys
>
> A candidate key is a determinant that determines all of the other columns in a relation. The SKU_DATA relation has two candidate keys: SKU and SKU_Description.Buyer is a determinant, but it is not a candidate key because it only determines Department.
>
> The ORDER_ITEM table has just one candidate key: (OrderNumber, SKU). The other determinant in this table, (Quantity, Price), is not a candidate key because it determines only ExtendedPrice. Candidate keys identify a unique row in a relation. Given the value of a candidate key, we can find one and only one row in the relation that has that value. For example, given the SKU value of 100100, we can find one and only one row in SKU_DATA. Similarly, given the OrderNumber and SKU values (2000, 101100), we can find one and only one row in ORDER_ITEM.

候选键候选键是一个决定关系中所有其他列的行列式。 SKU _ data 关系有两个候选键: SKU 和 SKU _ description。买方是一个决定因素，但它不是一个候选键，因为它只确定部门。

Order _ item 表只有一个候选键: (OrderNumber，SKU)。 此表中的另一个行列式(Quantity，Price)不是候选键，因为它只确定 ExtendedPrice。 **候选键标识关系中的唯一行**。 给定一个候选键的值，我们可以找到并且只能找到关系中具有该值的一行。 例如，给定 SKU 值为100100，我们可以在 SKU data 中找到一行并且只能找到一行。 类似地，给定 OrderNumber 和 SKU 值(2000,101100) ，我们可以在 ORDER _ item 中找到一行且只只能找到一行。

#### 主键

> Primary Keys
>
> When designing a database, one of the candidate keys is selected to be the primary key. This term is used because this key will be defined to the DBMS, and the DBMS will use it as its primary means for finding rows in a table. A table has only one primary key. The primary key can have one column, or it can be a composite. In this text, to clarify discussions we will sometimes indicate table structure by showing the name of a table followed by the names of the table’s columns enclosed in parentheses. When we do this, we will underline the column(s) that comprise the primary key.

设计数据库时，选择其中一个候选键作为主键。 之所以使用这个术语，是因为这个键将被定义到 DBMS 中，DBMS 将使用它作为在表中查找行的主要手段。 一个表只有一个主键。 **主键可以有一列，也可以是复合键**。 在本文中，为了澄清讨论，我们有时会用

表名称（列名称1，列名称2···，列名称n）

的方式表示表的结构。 当我们这样做时，我们会给 包含主键的列 加下划线 。

> For example, we can show the structure of SKU_DATA and ORDER_ITEM as follows: 
>
> SKU_DATA (SKU, SKU_Description, Department, Buyer) 
>
> ORDER_ITEM (OrderNumber, SKU, Quantity, Price, ExtendedPrice) 
>
> This notation indicates that SKU is the primary key of SKU_DATA and that (OrderNumber, SKU) is the primary key of ORDER_ITEM. In order to function properly, a primary key, whether it is a single column or a composite key, must have unique data values inserted into every row of the table. While in fact this may seem obvious, it is significant enough to be named the entity integrity constraint, and is a fundamental requirement for the proper functioning of a relational database.
>
> By the way What do you do if a table has no candidate keys? In that case, define the primary key as the collection of all of the columns in the table. Because there are no duplicate rows in a stored relation, the combination of all of the columns of the table will always be unique. Again, although tables generated by SQL manipulation may have duplicate rows, the tables that you design to be stored should never be constructed to have data duplication. Thus, the combination of all columns is always a candidate key (All Key).

例如，我们可以将 SKU _ data 和 ORDER _ item 的结构表示如下: 

SKU _ data (~~SKU~~，SKU _ description，Department，Buyer) 

ORDER _ item (~~OrderNumber~~，~~SKU~~，Quantity，Price，ExtendedPrice)

这个符号表示 SKU 是 SKU _ data 的主键，而 ORDER _ item 的主键是(OrderNumber，SKU)。 为了正常工作，**主键(无论是单个列还是复合键)必须在表的每一行中插入唯一的数值**。 虽然这可能看起来很明显，但是它的重要性足以被命名为实体完整性约束，并且是关系数据库正常工作的一个基本要求。

顺便问一下，如果一个表没有候选键，你该怎么办？ 在这种情况下，可以**将主键定义为表中所有列的集合**。 因为存储关系中没有重复的行，所以表中所有列的组合将始终是唯一的。 同样，尽管 SQL 操作生成的表可能有重复的行，但是设计用于存储的表不应该构造成数据重复。 因此，所有列的组合始终是一个候选键(All Key)。

#### 代理键

> Surrogate Keys
>
> A surrogate key is an artificial(人为的) column that is added to a table to serve as the primary key. The DBMS assigns a unique value to a surrogate key when the row is created. The assigned value never changes. Surrogate keys are used when the primary key is large and unwieldy. For example, consider the relation RENTAL_PROPERTY: 
>
> RENTAL_PROPERTY (Street, City, State/Province, Zip/PostalCode, Country, Rental_Rate) 
>
> The primary key of this table is (Street, City, State/Province, Zip/PostalCode, Country). As we will discuss further(in Chapter 6), for good performance a primary key should be short and, if possible, numeric. The primary key of RENTAL_PROPERTY is neither.
>
> In this case, the designers of the database would likely create a surrogate key. The structure of the table would then be: 
>
> RENTAL_PROPERTY (PropertyID, Street, City, State/Province, Zip/PostalCode, Country, Rental_Rate) 
>
> The DBMS can then be used to assign a numeric value to PropertyID when a row is created (exactly how this is done depends upon which DBMS product is being used). Using that key will result in better performance than using the original key. Note that surrogate key values are artificial and have no meaning to the users. In fact, surrogate key values are normally hidden in forms and reports.

代理键是添加到表中作为主键的，**人为增加的列** 。 当创建行时，DBMS 将一个唯一的值分配给代理键。 分配的值永远不会改变。 **当主键大且笨拙时，考虑使用代理键**。 例如，关系 RENTAL _ property: 

RENTAL _ property (~~Street，City，state / province，zip / postalcode，Country~~，RENTAL _ rate)

此表的主键是(Street，City，state / province，zip / postalcode，Country)。 正如我们将在第6章中进一步讨论的那样，为了获得良好的性能，**主键应该是简短的，如果可能的话，最好是数值的**。 Rental _ property 的主键不符合任何条件。

在这种情况下，数据库的设计人员可能会创建一个代理键。 表的结构是: 

RENTAL _ property (PropertyID，Street，City，state / province，zip / postalcode，Country，RENTAL _ rate)

然后，当创建行时，DBMS 可用于为 PropertyID 分配一个数值(具体如何完成取决于使用的是哪个 DBMS 产品)。 使用该键将比使用原始键获得更好的性能。 注意，代理键值是人为的，对用户没有意义。 事实上，代理键值通常隐藏在窗体和报表中。

#### 外键

> Foreign Keys 
>
> A foreign key is a column or composite of columns that is the primary key of a table other than the one in which it appears. The term arises because it is a key of a table foreign to the one in which it appears. In the following two tables, DEPARTMENT.DepartmentName is the primary key of DEPARTMENT and EMPLOYEE.DepartmentName is a foreign key. In this text, we will show foreign keys in italics: 
>
> DEPARTMENT (DepartmentName, BudgetCode, ManagerName) 
>
> EMPLOYEE (EmployeeNumber, EmployeeLastName, EmployeeFirstName, DepartmentName) 
>
> Foreign keys express relationships between rows of tables. In this example, the foreign key EMPLOYEE.DepartmentName stores the relationship between an employee and his or her department. Consider the SKU_DATA and ORDER_ITEM tables. SKU_DATA.SKU is the primary key of SKU_DATA, and ORDER_ITEM.SKU is a foreign key.
>
> SKU_DATA (SKU, SKU_Description, Department, Buyer) 
>
> ORDER_ITEM (OrderNumber, SKU, Quantity, Price, ExtendedPrice) 
>
> Notice that ORDER_ITEM.SKU is both a foreign key and also part of the primary key of ORDER_ITEM. This condition sometimes occurs, but it is not required. In the example above, EMPLOYEE.DepartmentName is a foreign key, but it is not part of the EMPLOYEE primary key. You will see some uses for foreign keys later in this chapter and the next, and you will study them at length in Chapter 6.

**外键是一个列或多个列的组合，这些列是表的主键，而不是它所在的表**。 这个术语之所以出现，是因为它是其他表的主键，而不是本表的主键。 在以下两个表中，DEPARTMENT.DepartmentName 是 DEPARTMENT 和 EMPLOYEE.DepartmentName 的主键。 在本文中，我们将以斜体显示外键: 

DEPARTMENT (~~DepartmentName~~、 BudgetCode、 ManagerName) 

EMPLOYEE (~~EmployeeNumber~~、 EmployeeLastName、 EmployeeFirstName、 *DepartmentName*)

外键表示表行之间的关系。 在这个示例中，外键 EMPLOYEE.DepartmentName 存储雇员与其部门之间的关系。 考虑 SKU _ data 和 ORDER _ item 表。 数据库。 Sku 是 SKU _ data 和 ORDER _ item 的主键。 Sku 是一个外键。

Sku _ data (~~SKU~~，SKU _ description，Department，Buyer)

ORDER _ item (~~OrderNumber~~，*~~SKU~~*，Quantity，Price，extended Price)

请注意该 ORDER _ item。 Sku 既是外键，也是 order_item 的主键的一部分。 这种情况有时会发生，但不是强制的。 在上面的示例中，EMPLOYEE.DepartmentName 是一个外键，但它不是 EMPLOYEE 主键的一部分。 在本章后面和下一章中，您将看到外键的一些用法，并将在第6章中详细研究它们。

> In most cases, we need to ensure that the values of a foreign key match a valid value of a primary key. For the SKU_DATA and ORDER_ITEM tables, we need to ensure that all of the values of ORDER_ITEM.SKU match a value of SKU_DATA.SKU. To accomplish this, we create a referential integrity constraint, which is a statement that limits the values of the foreign key. In this case, we create the constraint: SKU in ORDER_ITEM must exist in SKU in SKU_DATA This constraint stipulates that every value of SKU in ORDER_ITEM must match a value of SKU in SKU_DATA. By the way, While we have defined a referential integrity constraint to require a corresponding primary key value in the linked table, the technical definition of the referential integrity constraint allows for one other option–that the foreign key cell in the table is empty and does not have a value. If a cell in a table does not have a value, it is said to have a null value (we will discuss null values in Chapter 4). It is difficult to imagine a foreign key having null values in a real database when the referential integrity constraint is actually in use, and we will stick with our basic definition of the referential integrity constraint in this book. At the same time, be aware that the complete, formal definition of the referential integrity constraint does allow for null values in foreign key columns.
>
> We have defined three constraints so far in our discussion: 
>
> - The domain integrity constraint
> - The entity integrity constraint
> - The referential integrity constraint 
>
> The purpose of these three constraint, taken as a whole, is to create database integrity, which means that the data in our database will be useful, meaningful data.

在大多数情况下，我们需要确保**外键的值与主键的值**相匹配。 对于 SKU _ data 和 order_item 表，我们需要确保 order_item 的所有值。 Sku 与 SKU _ data 值匹配。 Sku. 为了实现这一点，我们创建了一个参照完整性约束，这是一个限制外键值的语句。 在这种情况下，我们创建约束: ORDER _ item 中的 SKU 必须对应于 SKU _ data 中的 SKU。这个约束规定 ORDER _ item 中的每个 SKU 值必须与 SKU _ data 中的 SKU 值相匹配。 顺便说一下，虽然我们已经定义了一个参照完整性 来要求在链接表中有一个相应的主键值，但是参照完整性的定义允许另外一个选项：表中的外键单元是空的，没有值。 如果表中的一个单元格没有值，则称其具有空值(我们将在第4章中讨论空值)。 在实际使用参照完整性 时，很难想象一个外键在实际数据库中具有空值，我们将在本书中坚持使用参照完整性的基本定义。 与此同时，要注意**完整的、正式的参照完整性约束定义确实允许外键列中存在空值**。

到目前为止，我们已经在讨论中定义了3个约束: 

- 域完整性约束
- 实体完整性约束
- 参照完整性约束

这3个约束的目的，作为一个整体，是创建数据库完整性，这意味着我们数据库中的数据将是有用的，有意义的数据。

## 4.3 范式

> Normal Forms
>
> All relations are not equal. Some are easy to process, and others are problematic. Relations are categorized into normal forms based on the kinds of problems that they have. Knowledge of these normal forms will help you create appropriate database designs. To understand normal forms, we need first to define modification anomalies.

并非所有的关系都是平等的。 有些很容易处理，有些则较为棘手。 根据各种问题种类的不同，关系可以划分为不同的范式。 了解这些范式将帮助您创建适当的数据库设计。 为了理解范式，我们首先需要定义修正异常。

### 修正异常

> Modification Anomalies
>
> Consider the EQUIPMENT_REPAIR relation in Figure 3-10, which stores data about manufacturing equipment and equipment repairs. Suppose we delete the data for repair number 2100. When we delete this row (the second one in Figure 3-10), we remove not only data about the repair, but also data about the machine itself.

考虑图3-10中的 EQUIPMENT _ repair 关系，该关系存储关于制造设备和设备维修的数据。 假设我们删除修复号2100的数据。 当我们删除这一行(图3-10中的第二行)时，我们不仅删除了关于修复的数据，还删除了关于机器本身的数据。

<img src="%E6%95%B0%E6%8D%AE%E5%BA%93.assets/image-20200701125423432.png" alt="image-20200701125423432" style="zoom: 80%;" />

> We will no longer know, for example, that the machine was a Lathe and that its AcquisitionPrice was 4750.00. When we delete one row, the structure of this table forces us to lose facts about two different things, a machine and a repair. This condition is called a deletion anomaly.
>
> Now suppose we want to enter the first repair for a piece of equipment. To enter repair data, we need to know not just RepairNumber, RepairDate, and RepairCost, but also ItemNumber, EquipmentType, and AcquisitionCost. If we work in the repair department, this is a problem because we are unlikely to know the value of AcquisitionCost. The structure of this table forces us to enter facts about two entities when we just want to enter facts about one. This condition is called an insertion anomaly.
>
> Finally, suppose we want to change existing data. If we alter a value of RepairNumber, RepairDate, or RepairCost, there is no problem. But if we alter a value of ItemNumber, EquipmentType, or AcquisitionCost, we may create a data inconsistency.
>
> To see why,(Tell me why?) suppose we update the last row of the table in Figure 3-10 using the data (100, 'Drill Press', 5500, 2500,'08/17/13', 275). Figure 3-11 shows the table after this erroneous update. The drill press has two different AcquisitionCosts. Clearly, this is an error. Equipment cannot be acquired at two different costs. If there were, say, 10,000 rows in the table, however, it might be very difficult to detect this error. This condition is called an update anomaly.



例如，当我们删除一行时，我们将不再知道：这台机器是一台车床，而且它的收购价格是4750.00。 这个表的结构设计，会导致一次删除丢失关于两个不同事物的数据，即一台机器记录和一个修复记录。 这种情况称为删除异常。

现在假设我们想要了解某台设备的第一次维修。要输入维修数据来定位这次维修，我们不仅需要知道修复号、修复日期和修复成本，还需要知道设备编号、设备类型和维修支出。 如果我们在维修部门工作，这是一个问题，因为我们不太可能知道采购成本的价值。 当我们只想输入关于一个实体的事实时，这个表的结构要求我们输入关于两个实体的事实。 这种情况称为插入异常。

最后，假设我们想要更改现有的数据。 如果我们修改 RepairNumber、 RepairDate 或 RepairCost 的值，就没有问题。 但是，如果我们修改 ItemNumber、 EquipmentType 或者 hungtioncost 的值，我们可能会创建一个数据不一致。

为什么? 假设我们使用数据(100，‘ Drill Press’ ，5500 , 2500，’08 / 17 / 13’ ，275)更新图3-10中表的最后一行。 图3-11显示了错误更新后的表。 钻床有两种不同的收购成本。 显然，这是一个错误。 因为同一件设备的购置成本不可能变化。 但是，如果表中有10,000行，则可能很难检测到此错误。 这种情况称为更新异常。

<img src="%E6%95%B0%E6%8D%AE%E5%BA%93.assets/image-20200701125551733.png" alt="image-20200701125551733" style="zoom:80%;" />

> By the way Notice that the EQUIPMENT_REPAIR table in Figures 3-10 and 3-11 duplicates data.
>
> For example, the AcquisitionCost of the same item of equipment appears several times. Any table that duplicates data is susceptible（容易受到影响的） to update anomalies like the one in Figure 3-11.
>
> A table that has such inconsistencies(矛盾) is said to have data integrity problems. As we will discuss further (in Chapter 4), to improve query speed we sometimes design a table to have duplicated data. Be aware, however, that any time we design a table this way, we open the door to data integrity problems.

顺便说一下，留意图3-10和3-11中的 EQUIPMENT _ repair 表重复的数据。

例如，同一个设备的购买成本会多次出现。 任何具有重复数据的表都容易受到更新异常的影响，如图3-11所示（ItemNumber=100的机器）。

有这种不一致的表称为有数据完整性问题。 正如我们将在第4章中进一步讨论的那样，为了提高查询速度，我们有时会设计一个具有重复数据的表。 但是要注意，只要我们以这种方式设计表，就有可能出现数据完整性问题。

### 范式的历史

> A Short history of Normal Forms
>
> When Codd defined the relational model, he noticed that some tables had modification anomalies. In his second paper, he defined first normal form, second normal form, and third normal form. He defined first normal form (1NF) as the set of conditions for a relation shown in Figure 3-4. Any table meeting the conditions in Figure 3-4 is therefore a relation in 1NF.

当 Codd 定义关系模型时，他注意到一些表格有修正异常。 在他的第二篇论文中，他定义了第一范式、第二范式和第三范式。 他将第一范式(1NF)定义为图3-4所示关系的条件集。 因此，任何满足图3-4中条件的表都是1NF 中的一个关系。

<img src="%E6%95%B0%E6%8D%AE%E5%BA%93.assets/image-20200701125838014.png" alt="image-20200701125838014" style="zoom:70%;" />

> Codd also noted that some tables (or, interchangeably in this book, relations) in 1NF had modification anomalies. He found that he could remove some of those anomalies by applying certain conditions. A relation that met those conditions, which we will discuss later in this chapter, was said to be in second normal form (2NF). He also observed, however, that relations in 2NF could also have anomalies, and so he defined third normal form (3NF), which is a set of conditions that removes even more anomalies and which we will also discuss later in this chapter.
>
> As time went by, other researchers found still other ways that anomalies can occur, and the conditions for Boyce-Codd Normal Form (BCNF) were defined. These normal forms are defined so that a relation in BCNF is in 3NF, a relation in 3NF is in 2NF, and a relation in 2NF is in 1NF. Thus, if you put a relation into BCNF, it is automatically in the lesser normal forms.
>
> Normal forms 2NF through BCNF concern anomalies that arise from functional dependencies. Other sources of anomalies were found later. They led to the definition of fourth normal form (4NF) and fifth normal form (5NF), both of which we will discuss later in this chapter.
>
> So it went, with researchers chipping away at modification anomalies, each one improving on the prior normal form. In 1982, Fagin published a paper that took a different tack. Instead of looking for just another normal form, Fagin asked, “What conditions need to exist for a relation to have no anomalies?” In that paper, he defined domain/key normal form (DK/NF). Fagin ended the search for normal forms by showing that a relation in DK/NF has no modification anomalies and, further, that a relation that has no modification anomalies is in DK/NF. DK/NF is discussed in more detail later in this chapter.

Codd 还指出，1NF 中的一些表(或者在本书中被称为关系的结构)有修改异常。 他发现，可以通过应用某些条件来消除一些异常现象。 我们将稍后讨论一个满足这些条件的关系，被称为第二范式(2NF)。 然而，他也观察到2NF 中的关系也可能有异常，所以他定义了第三范式(3NF) ，这是一组条件，可以去除更多的异常，我们也将稍后讨论。

随着时间的推移，其他研究人员还发现了异常发生的其他方式，并确定了 BC范式（BCNF）的条件。 这些范式的定义使得 BCNF 中的一个关系满足3NF，**满足3NF 中的关系自动满足2NF，满足2NF 的关系自动满足1NF**。 因此，如果你把一个关系放到 BCNF 中，会自动满足较小的范式。

标准形式2NF 到 BCNF 关注由函数依赖引起的异常。 后来发现了其他异常的来源。 他们导出了第四范式(4NF)和第五范式(5NF)的定义，这两个定义我们将稍后讨论。

于是，随着研究人员逐渐消除修正异常，每一个范式都在先前的版本上得到了改进。 1982年，费金发表了一篇采取不同策略的论文。 费金没有寻找另一种新的范式，而是寻求 “一个关系要具有什么样的条件，才不会出现任何异常? ” 在那篇文章中，他定义了域 / 键范式(dk / nf)。 费金通过证明凡是符合 dk / nf 中的关系都没有修改异常，进而证明范式没有修改异常的关系都符合dk/nf范式，从而结束了对范式的研究。 Dk / nf 将稍后更详细地讨论。

### 正规化理论

> Normalization Categories
>
> As shown in Figure 3-12, normalization theory can be divided into three major categories. Some anomalies arise from functional dependencies, some arise from multivalued dependencies, and some arise from data constraints and odd conditions.

正如图3-12所示，正规化理论可以分为三大类。 有些异常源于函数依赖，有些异常源于多值依赖，还有一些异常源于数据约束和奇数条件。

<img src="%E6%95%B0%E6%8D%AE%E5%BA%93.assets/image-20200701130046432.png" alt="image-20200701130046432" style="zoom:80%;" />

> BCNF, 3NF, and 2NF are all concerned with anomalies that are caused by functional dependencies. A relation that is in BCNF has no modification anomalies from functional dependencies. It is also automatically in 2NF and 3NF, and, therefore, we will focus on transforming relations into BCNF. However, it is instructive(有益的) to work through the progression of normal forms from 1NF to BCNF in order to understand how each normal form deals with specific anomalies, and we will do this later in this chapter.
> As shown in the second row of Figure 3-12, some anomalies arise because of another kind of dependency called a multivalued dependency. Those anomalies can be eliminated by placing each multivalued dependency in a relation of its own, a condition known as 4NF.
> The third source of anomalies is esoteric（深奥的）. These problems involve specific, rare, and even strange data constraints. Accordingly, we will not discuss them in this text.

Bcnf、3NF 和2NF 都与函数依赖引起的异常有关。 满足 Bcnf 的关系，不会出现因为函数依赖而产生的修正异常。 它在2NF 和3NF 中也是自动的满足的，因此，我们将着重于将关系转换为 BCNF。 然而，通过跟踪从1NF 到 BCNF 的范式转化，对于理解每个范式如何处理特定的异常是有益的，我们将在本章后面做这件事。
如图3-12的第二行所示，一些异常是由于另一种称为多值依赖的依赖关系引起的。 将每个多值依赖放在的独立表中，可以消除这些异常，这种情况被称为4NF。
异常的第三个来源是深奥的、只有内行才懂的的原因。 这些问题涉及特定的、罕见的、甚至奇怪的数据约束。 因此，我们不在本案文中讨论这些问题。

### 从第一范式到 BC范式

#### 第一范式

> First Normal Form
>
> Any table that meets the definition of a relation in Figure 3-4 is defined as being in 1NF. This means that the following must hold: 
>
> 1. The cells of a table must be a single value, and neither repeating groups nor arrays are allowed as values; 
> 2. all entries in a column must be of the same data type; 
> 3. each column must have a unique name, but the order of the columns in the table is not significant; 
> 4. no two rows in a table may be identical（完全一样的）, but the order of the rows is not significant

符合图3-4中关系定义的任何表都在1NF 中定义。 这意味着以下内容必须包含: 

1. 表的单元格必须是单个值，且不允许重复组或数组作为值；
2. 一列中的所有条目必须具有相同的数据类型；
3. 每列必须有唯一的名称，但表中列的顺序不重要；
4. 表中的任何两行都不能相同(完全一样的)，但行的顺序不重要

#### 第二范式

> Second Normal Form
>
> When Codd discovered anomalies in 1NF tables, he defined 2NF to eliminate some of these anomalies. A relation is in 2NF if and only if it is in 1NF and all non-key attributes are determined by the entire primary key. This means that if the primary key is a composite primary key, then no non-key attribute can be determined by an attribute or set of attributes that make up only part of the key. Thus, if you have a relation R (A, B, N, O, P) with the composite key (A, B), then none of the non-key attributes N, O, or P can be determined by just A or just B. Note that the only way a non-key attribute can be dependent on part of the primary key is if there is a composite primary key. This means that relations with single-attribute primary keys are automatically in 2NF. For example, consider the STUDENT_ACTIVITY relation: 
>
> STUDENT_ACTIVITY (StudentID, Activity, ActivityFee) 
>
> The STUDENT_ACTIVITY relation is shown with sample data in Figure 3-13.Note that STUDENT_ACTIVITY has the composite primary key (StudentID, Activity), which allows us to determine the fee a particular student will have to pay for a particular activity. However, because fees are determined by activities, Fee is also functionally dependent on just Activity itself, and we can say that Fee is partially dependent on the key of the table. The set of functional dependencies is therefore: 
>
> (StudentID, Activity)→ (ActivityFee) 
>
> (Activity) → (ActivityFee)

当Codd在满足1NF的表中发现异常时，他定义了2NF来消除其中的一些异常。 **当且仅当关系在1NF中，并且所有非键属性由整个主键确定时，关系才在2NF中**。 这意味着，如果主键是复合主键，则非键属性不能由仅构成该键一部分的属性或属性集确定。 因此，如果表R(A，B，N，O，P)的组合键为(A，B)，则非键属性N、O或P都不能仅由A或B确定。请注意，**非键属性依赖于部分主键的唯一方式是存在组合主键**。 这意味着**单属性主键的表自动满足2NF**。 举个例子，考虑STUDENT_ACTIVITY：

STUDENT_ACTIVITY (~~StudentID, Activity~~, ActivityFee)

学生_活动关系如图3-13中的示例数据所示。 请注意，Student_Activity具有复合主键(StudentID，Activity)，它允许我们查找：特定学生为特定活动所支付的费用。 但是，因为费用是由活动决定的，所以费用在函数上也仅仅取决于活动本身，我们可以说费用部分依赖于表的键。 因此，函数依赖项集合是：

(StudentID，Activity)→(ActivityFee)

(Activity)→(ActivityFee)

> Thus, there is a non-key attribute determined by part of the composite primary key, and the STUDENT_ACTIVITY relation is not in 2NF. What do we do in this case? We will have to move the columns of the functional dependency based on the partial primary key attribute into a separate relation while leaving the determinant in the original relation as a foreign key. We will end up with two relations: 
>
> STUDENT_ACTIVITY (StudentID, Activity) 
>
> ACTIVITY_FEE (Activity, ActivityFee)

因此，存在由复合主键的一部分确定的非键属性，因此Student_Activity关系不符合2NF。 在这种情况下我们该怎么做？ 我们必须**把基于部分主键属性的函数依赖项的列，移动到单独的表中，同时将原始关系中的列保留做为外键**。 我们将得到两个关系：

Student_Activity(StudentID，Activity)

Activity_Fee(Activity，ActivityFee)

<img src="%E6%95%B0%E6%8D%AE%E5%BA%93.assets/image-20200701154205742.png" alt="image-20200701154205742" style="zoom: 50%;" />

> The Activity column in STUDENT_ACTIVITY becomes a foreign key. The new relations are shown in Figure 3-14. Now, are the two new relations in 2NF? Yes. STUDENT_ACTIVITY still has a composite primary key, but now has no attributes that are dependent on only a part of this composite key. ACTIVITY _FEE has a set of attributes (just one each in this case) that are dependent on the entire primary key.

STUMENT_ACTIVATION中的ACTIVATION列此时修改为外键。 新的关系如图3-14所示。 现在，这两个新关系符合2NF吗？ 是。 STUMENT_ACTIVATION仍然有一个复合主键，但是现在没有任何一个属性，仅依赖于该复合键的一部分。 ACTIVITY _FEE的一系列（非键）属性必须依赖于整个主键。

<img src="%E6%95%B0%E6%8D%AE%E5%BA%93.assets/image-20200701154256577.png" alt="image-20200701154256577" style="zoom: 67%;" />

#### 第三范式

> Third Normal Form
>
> However, the conditions necessary for 2NF do not eliminate all anomalies. To deal with additional anomalies, Codd defined 3NF. A relation is in 3NF if and only if it is in 2NF and there are no non-key attributes determined by another non-key attribute.
>
> The technical name for a non-key attribute determined by another non-key attribute is transitive dependency. We can therefore restate the definition of 3NF: A relation is in 3NF if and only if it is in 2NF and it has no transitive dependencies. Thus, in order for our relation R (A, B, N, O, P) to be in 3NF, none of the non-key attributes N, O, or P can be determined by N, O, or P. 

然而，2NF并不能消除所有异常。 为了处理其他异常，Codd定义了3NF。 **当且仅当关系满足2NF，并且不存在由另一个非键属性确定的非键属性时（即：非键属性之间互相不能唯一确定），该关系才满足3NF。**

由另一个非键属性确定的非键属性的技术名为传递依赖。 因此，我们可以定义3NF：**关系满足3NF的充要条件是，它满足2NF，并且它没有传递依赖。** 因此，为了使我们的关系R(A，B，N，O，P)满足3NF，非关键属性N、O、P都不能由N、O、P来确定。

<img src="%E6%95%B0%E6%8D%AE%E5%BA%93.assets/image-20200701154357260.png" alt="image-20200701154357260" style="zoom: 67%;" />

> For example, consider the relation STUDENT_HOUSING (StudentID, Building, Fee) shown in Figure 3-15. The STUDENT_HOUSING schema is:  STUDENT_HOUSING (StudentID, Building, HousingFee)
>
> Here we have a single-attribute primary key, StudentID, so the relation is in 2NF because there is no possibility of a non-key attribute being dependent on only part of the primary key. Furthermore, if we know the student, we can determine the building where he or she is residing, so:
>
> (StudentID) → (Building) 
>
> However, the building fee is independent of which student is housed in the building, and, in fact, the same fee is charged for every room in a building. Therefore, Building determines HousingFee: 
>
> (Building) → (HousingFee) 
>
> Thus, a non-key attribute (HousingFee) is functionally determined by another non-key attribute (Building), and the relation is not in 3NF. To put the relation into 3NF, we will have to move the columns of the functional dependency into a separate relation while leaving the determinant in the original relation as a foreign key. We will end up with two relations: 
>
> STUDENT_HOUSING (StudentID, Building) 
>
> BUILDING_FEE (Building, HousingFee).
>
> The Building column in STUDENT_HOUSING becomes a foreign key. The two relations are now in 3NF (work through the logic yourself to make sure you understand 3NF) and are shown in Figure 3-16.

例如，考虑图3-15所示的关系：
 STUDENT_HOUSING (~~StudentID~~, Building, HousingFee)

这里我们有一个单属性主键StudentID，因此关系满足2NF（因为非键属性不可能只依赖于主键的一部分）。 此外，如果我们唯一确定了学生，我们可以确定他或她居住的大楼，因此：

(StudentID) → (Building) 

然而，建筑费与房间里居住的学生的身份无关，实际上，大楼中的每个房间都收取相同的费用。 因此，Building确定HousingFee：

(Building)→(HousingFee)

因此，一个非键属性(HousingFee)在函数依赖于另一个非键属性(Building)，并且该关系不满足3NF。 要使关系满足3NF，我们必须将有函数依赖的列，移动到单独的表中，同时将原始关系中的行列式保留为外键。 我们将最终得到两个关系：

Student_Hook(~~StudentID~~，*Building*)

Building_Fee(~~Building~~，HousingFee)。

学生宿舍中的Building列成为外键。 这两个关系现在满足3NF（这里建议自己理一理逻辑，以确保完全理解）如图3-16所示。

#### BC范式

> Boyce-Codd Normal Form
>
> Some database designers normalize their relations to 3NF. Unfortunately, there are still anomalies due to functional dependences in 3NF. Together with Raymond Boyce, Codd defined BCNF to fix this situation. A relation is in BCNF if and only if it is in 3NF and every determinant is a candidate key. For example, consider the relation STUDENT_ADVISOR shown in Figure 3-17, where a student (StudentID) can have one or more majors (Major), a major can have one or more faculty advisors (AdvisorName), and a faculty member advises in only one major area. Note that the figure shows two students (StudentIDs 700 and 800) with double majors (both students show Majors of Math and Psychology) and two Subjects (Math and Psychology) with two Advisors. Because students can have several majors, StudentID does not determine Major. Moreover, because students can have several advisors, StudentID does not determine AdvisorName. Therefore, StudentID by itself cannot be a key. However, the composite key (StudentID, Major) determines AdvisorName, and the composite key (StudentID, AdvisorName) determines Major. This gives us (StudentID, Major) and (StudentID, AdvisorName) as two candidate keys.

一些数据库设计人员将他们的关系规范化为3NF。 不幸的是，由于3NF 中的函数依赖，仍然存在一些异常。 Codd 和 Raymond Boyce 一起定义了 BCNF 来解决这个问题。 一个满足 BCNF 的关系必须同时满足 3NF ，并且每个列都是候选键。 例如，考虑图3-17所示的 STUDENT _ advisor 关系，其中一个学生(StudentID)可以有一个或多个专业(Major) ，一个专业可以有一个或多个导师(AdvisorName) ，而教师成员只能在一个主要领域提供指导。 请注意，该图显示两名学生(学生id为700和800)拥有双专业(两名学生同时修习数学和心理学专业)和两门学科(数学和心理学) ，并有两名导师。 因为学生可以有多个专业，所以学生不能唯一决定专业。 此外，因为学生可以同时拥有几个导师，所以学生不能唯一决定导师。 因此，StudentID 本身不能成为键（非键属性）。 但是，复合键(StudentID、 Major) 可以决定 AdvisorName，复合键(StudentID、 AdvisorName) 可以决定 Major。 因此给出了两个候选键 (StudentID、 Major) 和 (StudentID、 AdvisorName)。

<img src="%E6%95%B0%E6%8D%AE%E5%BA%93.assets/image-20200701164631109.png" alt="image-20200701164631109" style="zoom:80%;" />

> We can select either of these as the primary key for the relation. Thus, two
> STUDENT_ADVISOR schemas with different candidate keys are possible: 
>
> STUDENT_ADVISOR (StudentID, Major, AdvisorName)
>
> STUDENT_ADVISOR (StudentID, Major, AdvisorName) 
>
> Note that STUDENT_ADVISOR is in 2NF because it has no non-key attributes in the sense that every attribute is a part of at least one candidate key. This is a subtle (微妙的)condition, based on the fact that technically the definition of 2NF states that no non-prime attribute can be partially dependent on a candidate key, where a non-prime attribute is an attribute that is not contained in any candidate key. Furthermore, STUDENT_ADVISOR is in 3NF because there are no transitive dependencies in the relation. The two candidate keys for this relation are overlapping （重叠） candidate keys because they share the attribute StudentID. When a table in 3NF has overlapping candidate keys, it can still have modification anomalies based on functional dependencies. In the STUDENT_ADVISOR relation, there will be modification anomalies because there is one other functional dependency in the relation. Because a faculty member can be an advisor for only one major area, AdvisorName determines Major. Therefore, AdvisorName is a determinant but not a candidate key. Suppose that we have a student (StudentID = 300) majoring in psychology (Major =Psychology) with faculty advisor Perls (AdvisorName = Perls). Further, assume that this row is the only one in the table with the AdvisorName value of Perls. If we delete this row, we will lose all data about Perls. This is a deletion anomaly. Similarly, we cannot insert the data to represent the Economics advisor Keynes until a student majors in Economics. This is an insertion anomaly. Situations like this led to the development of BCNF. What do we do with the STUDENT_ADVISOR relation? As before, we move the functional dependency creating the problem to another relation while leaving the determinant in the original relation as a foreign key. In this case, we will create the relations: STUDENT_ADVISOR (StudentID, AdvisorName) ADVISOR_SUBJECT (AdvisorName, Major) The AdvisorName column in STUDENT_ADVISOR is the foreign key, and the two final relations are shown in Figure 3-18.

我们可以选择其中任何一个作为关系的主键。 因此，有两个带有不同候选键的 STUDENT _ advisor 模式是可能的: 

STUDENT _ advisor (~~StudentID，Major~~，AdvisorName)

STUDENT _ advisor (~~StudentID~~，Major，~~AdvisorName~~)

注意，STUDENT _ advisor 满足2NF，因为它没有非键属性，即每个属性都是至少是一个候选键的一部分。 这是一个微妙的条件，从技术上来说，2NF 的定义表明：任何非主要属性都不能只由候选键的一部分决定，其中**非主要属性是一个不包含在任何候选键中的属性**。 此外，STUDENT _ advisor 满足3NF，因为关系中没有传递依赖。 这种关系的两个候选键有重叠，因为它们共享属性 StudentID。 **当3NF 中的一个表有重叠的候选键时，它仍然可能出现基于函数依赖关系的修改异常**。 在 STUDENT _ advisor 关系中，会出现修改异常，因为关系中还有另外一个函数依赖项。 由于一个导师只能担任一个主要领域的顾问，所以导师可以确定专业。 因此，导师 是一个决定因素，而不是一个候选键。 假设我们有一个主修心理学(Major =Psychology)的学生(StudentID = 300) ，他的导师是珀尔斯(AdvisorName = Perls)。 此外，假设这一行是表中唯一一个值为 Perls 的 AdvisorName 行。 如果我们删除这一行，我们将失去有关 Perls 的所有数据。 这是一个删除异常。 同样，在没有学生主修经济学的时候，我们无法存储经济学导师凯恩斯。 这是一个插入异常。 这样的情况导致了 BCNF 的发展。 我们如何处理学生顾问关系？ 与前面一样，我们将导致问题的函数依赖关系移动到另一个表，同时将原始关系中的列作为外键保留。 在这种情况下，我们将创建关系: 

STUDENT _ ADVISOR (~~StudentID，*AdvisorName*~~) 

ADVISOR _ subject (~~AdvisorName~~，Major) 

STUDENT _ ADVISOR 中的 AdvisorName 列是外键，最后两个关系如图3-18所示。

<img src="%E6%95%B0%E6%8D%AE%E5%BA%93.assets/image-20200701164709471.png" alt="image-20200701164709471" style="zoom:80%;" />

#### 用 BCNF 消除函数依赖中的异常

> Eliminating Anomalies from Functional Dependencies with BCNF
>
> Most modification anomalies occur because of problems with functional dependencies. You can eliminate these problems by progressively（逐步地） testing a relation for 1NF, 2NF, 3NF, and BCNF using the definitions of these normal forms given previously. We will refer to this as the “Step-by-Step” method.

大多数修改异常是由于函数依赖的问题引起的。 可以通过使用前面给出的这些范式的定义**逐步测试1NF、2NF、3NF 和 BCNF 的关系**来消除这些问题。 我们将这种方法称为“循序渐进”法。

<img src="%E6%95%B0%E6%8D%AE%E5%BA%93.assets/image-20200701171510239.png" alt="image-20200701171510239" style="zoom: 50%;" />

> You can also eliminate such problems by simply designing (or redesigning) your tables so that every determinant is a candidate key. This condition, which, of course, is the definition of BCNF, will eliminate all anomalies due to functional dependencies. We will refer to this method as the “Straight-to-BCNF” or “general normalization” method.
>
> We prefer the “Straight-to-BCNF” general normalization strategy（策略） and will use it extensively（广泛）, but not exclusively(唯一), in this book. However, this is merely our preference（这仅仅是我们的偏好）—either method produces the same results, and you (or your professor) may prefer the “Step-by-Step” method. The general normalization method is summarized in Figure 3-19. Identify every functional dependency in the relation, and then identify the candidate keys. If there are determinants that are not candidate keys, then the relation is not in BCNF and is subject to modification anomalies. To put the relation into BCNF, follow the procedure in step 3. To fix this procedure in your mind, we will illustrate it with five different examples. We will also compare it to the “Step-by-Step” approach.

还可以通过简单地**设计(或重新设计)表，使每个行列式都成为候选键**，从而消除这些问题。 当然，这个条件就是 BCNF 的定义，它将消除由函数依赖引起的所有异常。 我们将这种方法称为“直达 bcnf法”或“通用归一化”法。

我们更喜欢“直达 bcnf”的一般规范化策略 ，并将在本书中广泛使用，但不仅仅是唯一的方案。 然而，这仅仅是我们的偏好：任何一种方法都产生相同的结果，而你(或你的教授)可能更喜欢“循序渐进”法。 图3-19总结了一般的归一化方法。 识别关系中的每个函数依赖项，然后识别候选键。 如果有决定因素不是候选键，则关系不满足 BCNF ，并且会出现修改异常。 按照步骤3中的步骤可以使关系满足 BCNF 中。 为了让你记住这个过程，我们将用五个不同的例子来说明它。 我们也会把它与“循序渐进”法作比较。

<img src="%E6%95%B0%E6%8D%AE%E5%BA%93.assets/image-20200701171908795.png" alt="image-20200701171908795" style="zoom: 50%;" />

|           Process for Putting a Relation into BCNF           |                    使关系满足BCNF 的步骤                     |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
|            Identily every functional dependency.             |                      辨别每个函数依赖。                      |
|                ldentity every candidate key.                 |                        辨别每个候选键                        |
| If there is a functional dependency that has a determinant that is not a candidate key |              如果函数依赖中有决定因素不是候选键              |
| A. Move the columns of that functional dependency into a new relation.<br/>B. Make the determinant of that functional dependency the primary key of the new relation.<br/>C. Leave a copy of the determinant as a foreign key in the original relation.<br/>D. Create a referential integrity constraint between the original relation and the new relation. | 1. 将该函数依赖项的列移到一个新表中。<br/>2. 将函数依赖关系的决定因素作为新关系的主键。<br/>3. 在原始关系中保留决定因素的一个副本作为外键。<br/>4. 在原始表和新表之间创建一个参照完整性约束。 |
| Repeat step 3 until every determinant of every relation is a candidate key. |         重复步骤3，直到每个关系的决定因素都是候选键          |
| Note: In step 3, if there is more than one such functional dependency, <br>start with the one with the most columns. | 注意: 在步骤3中，如果有多个这样的函数依赖项，那么从列最多的那个开始。 |


> Our process rule that a relation is in BCNF if and only if every determinant is a candidate key is summed up in（总结了） a variation(变异) of a widely known phrase: I swear to construct my tables so that all non-key columns are dependent on the key, the whole key and nothing but the key, so help me Codd!
>
> The goal of the normalization process is to create relations that are in BCNF. It is sometimes stated that the goal is to create relations that are in 3NF, but after the discussion in this chapter, you should understand why BCNF is preferred to 3NF. Note that there are some problems that are not resolved by even BCNF, and we will discuss those after we discuss our examples of normalizing to BCNF.

Our process rule that a relation is in BCNF if and only if every determinant is a candidate key is summed up in a variation  of a widely known phrase: I swear to construct my tables so that all non-key columns are dependent on the key, the whole key and nothing but the key, so help me Codd!

我们的过程规定了，**关系满足 BCNF 当且仅当：每一个决定因素都是一个候选键**。

这个规则被总结为一个广为人知的版本 : 我庄严发誓，我在建表过程中，所有非键属性都依赖于键，无他，只有整个键，所以 Codd 大神，请保佑我！

标准化的目标是建立满足 BCNF 的关系。 有时候，目标是创建满足 3NF 的关系，但是在本章的讨论之后，你应该理解为什么 BCNF 比3NF 更受欢迎。 请注意，**有些问题即使是 BCNF 也无法解决**，我们将在 BCNF 的规范化示例之后讨论这些问题。

#### 标准化示例1

> Normalization example 1 
>
> Consider the SKU_DATA table: SKU_DATA (SKU, SKU_Description, Department, Buyer)
>
> As discussed earlier, this table has three functional dependencies: 
>
> SKU → (SKU_Description, Department, Buyer) 
>
> SKU_Description→ (SKU, Department, Buyer) 
>
> Buyer → Department 

考虑 SKU _ data 表：SKU_DATA (SKU, SKU_Description, Department, Buyer)

如前所述，该表有三个函数依赖项:

SKU → (SKU_Description, Department, Buyer)  

SKU_Description→ (SKU, Department, Buyer)  

Buyer → Department 

且候选键：Sku 和 SKU _ Descripion

##### “循序渐进”法

> Normalization Example 1: The “Step-by-Step” Method   
>
> Both SKU and SKU_Descripion are candidate keys. Logically, SKU makes more sense as the primary key because it is a surrogate key, so our relation, which is shown in Figure 3-20, is: 
>
> SKU_DATA (SKU, SKU_Description, Department, Buyer) 
>
> Checking the relation against Figure 3-4, we find that SKU_DATA is in 1NF. 
>
> Is the SKU_DATA relation in 2NF?
>
> A relation is in 2NF if and only if it is in 1NF and all non-key attributes are determined by the entire primary key. Because the primary key SKU is a single attribute key, all the non-key attributes are therefore dependent on the entire primary key. Thus, the SKU_DATA relation is in 2NF.
>
> Is the SKU_DATA relation in 3NF?
>
> A relation is in 3NF if and only if it is in 2NF and there are no non-key attributes determined by another non-key attribute. Because we seem to have two non-key attributes (SKU_Description and Buyer) that determine non-key attributes, the relation is not in 3NF! However, this is where things get a bit tricky. A non-key attribute is an attribute that is neither (1) a candidate key itself nor (2) part of a candidate key. SKU_Description, therefore, is not a non-key attribute (sorry about the double negative). The only non-key attribute is Buyer! Therefore, we must remove only the functional dependency 
>
> Buyer → Department 
>
> We will now have two relations: 
>
> SKU_DATA_2 (SKU, SKU_Description, Buyer) 
>
> BUYER (Buyer, Department) 

Sku 和 SKU _ Descripion 都是候选键。 从逻辑上讲，SKU 作为主键更有意义，因为它是一个代理键，所以我们的表，可以表示为如图3-20所示： 

SKU _ data (<u>SKU</u>，SKU _ description，Department，Buyer)

**检查关系对照图3-4**，我们发现 SKU _ data 满足1NF。 

Sku _ data 关系满足2NF吗？

**当且仅当关系满足1NF 并且所有非键属性都由整个主键确定时，关系才满足2NF**。 由于主键 SKU 是单个属性键，因此所有非键属性只能由整个主键决定。 因此，SKU _ data 关系满足2NF。 

Sku _ data 关系满足3NF 吗？

**当且仅当关系位于2NF 且非键属性之间不能互相确定时，关系才满足3NF。** 因为我们似乎有两个非键属性(SKU _ description 和 Buyer)是决定因素，所以关系不满足3NF！ 然而，这就是事情变得有点棘手的地方。 **非键属性是一种既不是候选键本身也不是候选键的一部分**。 因此，SKU _ description 不是一个非键属性。 唯一的非键属性是 Buyer！ 因此，我们只需要删除以下的函数依赖即可：

Buyer → Department 

于是得到两个表:

SKU _ data _ 2(<u>SKU</u>，SKU _ description，*Buyer*) 

Buyer (~~Buyer~~，Department) 

<img src="%E6%95%B0%E6%8D%AE%E5%BA%93.assets/image-20200701172029433.png" alt="image-20200701172029433" style="zoom: 67%;" />

> Is SKU_DATA_2 in 3NF?
>  Yes, it is—there are no non-key attributes that determine another non-key attribute. 
>
> Is the SKU_DATA_2 relation in BCNF? 
>
> A relation is in BCNF if and only if it is in 3NF and every determinant is a candidate key. The determinants in SKU_DATA_2 are SKU and SKU_Description:   
>
> SKU → (SKU_Description, Buyer)   
>
> SKU_Description→ (SKU, Buyer)

SKU _ data _ 2满足3NF 吗？ 

是的，此时没有非键属性可以决定另一个非键属性。 

SKU _ data _ 2满足BCNF吗？ 

一个关系满足 BCNF ，当且仅当它满足 3NF ，并且每个决定因素都是候选键。 此时Sku _ data _ 2中的决定因素为 SKU 和 SKU_Description:  

SKU → (SKU_Description, Buyer)     

SKU_Description→ (SKU, Buyer)

> Both determinants are candidate keys (they both determine all the other attributes in the relation). Thus, every determinant is a candidate key, and the relationship is in BCNF. At this point, we need to check the BUYER relation to determine if it is in BCNF. Work through the steps yourself for BUYER to check your understanding of the “Step-by-Step” method. You will find that BUYER is in BCNF, and therefore our normalized relations, as shown with the sample data in Figure 3-21, are: 
>
> SKU_DATA_2 (SKU, SKU_Description, Buyer) 
>
> BUYER (Buyer, Department) 
>
> Both of these tables are now in BCNF and will have no anomalies due to functional dependencies. For the data in these tables to be consistent, however, we also need to define a referential integrity constraint (note that this is step 3D in Figure 3-19): SKU_DATA_2.Buyer must exist in BUYER.Buyer This statement means that every value in the Buyer column of SKU_DATA_2 must also exist as a value in the Buyer column of BUYER.

这两个决定因素都是候选键(它们都决定了关系中的所有其他属性)。 因此，每个决定因素都是一个候选键，这个表满足 BCNF 。 通过这个方式，我们也可以检查 BUYER 表，来确定它是否满足 BCNF 。 你自己通过这些步骤为 BUYER 复习“循序渐进”法。 您会发现 BUYER 在 BCNF 中，因此我们的对其进行了关系规范化，如图3-21中的样本数据所示: 

SKU _ data _ 2(SKU，SKU _ description，BUYER) 

BUYER (BUYER，Department)

这两个表都满足 BCNF ，并且没有由于函数依赖性而出现的异常。 然而，**为了使这些表中的数据保持一致，我们还需要定义一个参照完整性约束**(注意，这是图3-19中的步骤3 d) : SKU_DATA_2.Buyer必须存在于BUYER.Buyer。这句话意味着 SKU _ data _ 2的 Buyer 列中的每一个值也必须同时存在于 Buyer 列中。

<img src="%E6%95%B0%E6%8D%AE%E5%BA%93.assets/image-20200701172112987.png" alt="image-20200701172112987" style="zoom: 80%;" />

##### ”直达BCNF“法

> Normalization Example 1: The “Straight-to-BCNF” Method 
>
> Now let’s rework this example using the “Straight-to-BCNF” method.
>
> SKU and SKU_Description determine all of the columns in the table, so they are candidate keys. Buyer is a determinant, but it does not determine all of the other columns, and hence it is not a candidate key. Therefore, SKU_DATA has a determinant that is not a candidate key and is therefore not in BCNF. It will have modification anomalies. To remove such anomalies, in step 3A in Figure 3-19, we move the columns of functional dependency whose determinant is not a candidate key into a new table. In this case, we place Buyer and Department into a new table: BUYER (Buyer, Department) Next, in step 3B in Figure 3-19, we make the determinant of the functional dependency the primary key of the new table. In this case, Buyer becomes the primary key: 
>
> BUYER (Buyer, Department) 
>
> Next, following step 3C in Figure 3-19, we leave a copy of the determinant as a foreign key in the original relation. Thus, SKU_DATA becomes SKU_DATA_2: SKU_DATA_2 (SKU, SKU_Description, Buyer) The resulting tables are thus: SKU_DATA_2 (SKU, SKU_Description, Buyer)
>
> BUYER (Buyer, Department) 
>
> where SKU_DATA_2.Buyer is a foreign key to the BUYER table. Both of these tables are now in BCNF and will have no anomalies due to functional dependencies. For the data in these tables to be consistent, however, we also need to define the referential integrity constraint in step 3D in Figure 3-19: SKU_DATA_2.Buyer must exist in BUYER.Buyer This statement means that every value in the Buyer column of SKU_DATA_2 must also exist as a value in the Buyer column of BUYER. Sample data for the resulting tables is the same as shown in Figure 3-21. Note that both the “Step-by-Step” method and the “Straight-to-BCNF” method produced exactly the same results. Use the method you prefer; the results will be the same. To keep this chapter reasonably short, we will use only the “Straight-to-BCNF” method for the rest of the normalization examples.

现在让我们使用“ Straight-to-BCNF”方法重新编写这个示例。

Sku 和 SKU _ description 决定了表中的所有列，因此它们是候选键。 Buyer 是一个决定因素，但它不能决定所有其他列，因此它不是一个候选键。 因此，SKU _ data 的**决定因素不是候选键，因此不满足 BCNF ，会出现修改异常**。 为了去除这些异常，在图3-19中的步骤3A 中，我们将函数依赖的列（Buyer 和 Department）移动到一个新表中： 

Buyer (Buyer，Department)

接下来，在图3-19中的步骤3B 中，我们将函数依赖的决定因素作为新表的主键。 在这种情况下，Buyer 成为主键: 

Buyer (~~Buyer~~，Department)

接下来，在图3-19中的步骤3C 之后，我们将决定因素的一个副本作为原始关系中的外键保留下来。 这样处理的结果是: 

SKU _ data _ 2(~~SKU~~，SKU _ description，*Buyer*) 

Buyer (~~Buyer~~，Buyer，Department) 

其中 SKU_DATA_2.Buyer是 BUYER 表的外键。 这两个表都满足 BCNF ，并且没有因为函数依赖而出现的异常。 然而，为了使这些表中的数据保持一致，我们还需要在图3-19中的步骤3 d 中定义参照完整性约束: SKU_DATA_2.Buyer必须存在于BUYER.Buyer。这句话意味着 SKU _ data _ 2 的 Buyer 列中的每一个值必须存在于 BUYER 表的 Buyer 列中。 结果表的示例数据与图3-21所示相同。 请注意，**“循序渐进”方法和“直达 bcnf”方法产生的结果完全相同**。使用你喜欢的方法，结果是一样的。 为了使这一章的篇幅合理缩短，我们将只对其余的规范化示例使用“ 直达bcnf”方法。

#### 标准化示例2

> Normalization example 2
>
> Now consider the EQUIPMENT_REPAIR relation in Figure 3-10. The structure of the table is: 
>
> EQUIPMENT_REPAIR (ItemNumber, EquipmentType, AcquisitionCost, RepairNumber, RepairDate, RepairCost) 
>
> Examining the data in Figure 3-10, the functional dependencies are: 
>
> ItemNumber → (EquipmentType, AcquisitionCost) 
>
> RepairNumber →(ItemNumber, EquipmentType, AcquisitionCost, RepairDate, RepairCost) 
>
> Both ItemNumber and RepairNumber are determinants, but only RepairNumber is a candidate key. Accordingly, EQUIPMENT_REPAIR is not in BCNF and is subject to modification anomalies. Following the procedure in Figure 3-19, we place the columns of the problematic functional dependency into a separate table, as follows: 
>
> EQUIPMENT_ITEM (ItemNumber, EquipmentType, AcquisitionCost) 
>
> and remove all but ItemNumber from EQUIPMENT_REPAIR (and rearrange the columns so that the primary key RepairNumber is the first column in the relation) to create: 
>
> REPAIR (RepairNumber, ItemNumber, RepairDate, RepairCost) 
>
> We also need to create the referential integrity constraint: REPAIR.ItemNumber must exist in EQUIPMENT_ITEM.ItemNumber Data for these two new relations are shown in Figure 3-22.

现在考虑图3-10中的 EQUIPMENT _ repair 关系。 该表的结构为: 

EQUIPMENT _ repair (ItemNumber，EquipmentType，hungtioncost，RepairNumber，RepairDate，RepairCost)

检查图3-10中的数据，得到函数依赖关系为: 

ItemNumber →(EquipmentType，hungtioncost) 

RepairNumber →(ItemNumber，EquipmentType，repairtype，cost，RepairDate，RepairCost)

因此，EQUIPMENT _ repair 不满足 BCNF ，并且会出现修改异常。 按照图3-19中的过程，我们将有问题的函数依赖项的列放置到一个单独的表中，如下: 

EQUIPMENT _ item (~~ItemNumber~~，EquipmentType，hundredtioncost)

并从 EQUIPMENT _ REPAIR 中删除除了 ItemNumber 以外的所有列，并重新排列所有列，使主键 RepairNumber 成为关系中的第一个列，得到: 

REPAIR (~~RepairNumber~~，*number*，RepairDate，repaircost)

我们还需要创建参照完整性约束: REPAIR.RepairNumber 必须在 EQUIPMENT_ITEM.ItemNumber 中存在。 这两个新关系的数据如图3-22所示。

<img src="%E6%95%B0%E6%8D%AE%E5%BA%93.assets/image-20200701211406666.png" alt="image-20200701211406666" style="zoom: 80%;" />

> There is another, more intuitive way to think about normalization. Do you remember your eighth-grade English teacher? She said that every paragraph should have a single theme. If you write a paragraph that has two themes, you should break it up into two paragraphs, each with a single theme. The problem with the EQUIPMENT_REPAIR relation is that it has two themes: one about repairs and a second about items. We eliminated modification anomalies by breaking that single table with two themes into two tables, each with a single theme. Sometimes, it is helpful to look at a table and ask, “How many themes does it have?” If it has more than one, redefine the table so that it has a single theme.

还有一种更直观的方式来考虑标准化。 你还记得你八年级的英语老师吗？ 她说每一段都应该有一个单一的主题。 如果你写的一个段落有两个主题，你应该把它分成两个段落，每个段落都有一个主题。 设备维修关系的问题在于它有两个主题: 一个关于维修，另一个关于物品。 我们将带有两个主题的单个表拆分为两个表，每个表都带有一个主题，从而消除了修改异常。 有时候，看着一张桌子问“它有多少个主题? ”这样的问题是很有帮助的。如果它有多个主题，则重新定义表，使其具有单个主题。

#### 标准化示例3

> Normalization example 3 
>
> Consider now the Cape Codd database ORDER_ITEM relation with the structure: 
>
> ORDER_ITEM (OrderNumber, SKU, Quantity, Price, ExtendedPrice) 
>
> with functional dependencies: 
>
> (OrderNumber, SKU) → (Quantity, Price, ExtendedPrice) 
>
> (Quantity, Price) → ExtendedPrice 
>
> This table is not in BCNF because the determinant (Quantity, Price) is not a candidate key. We can follow the same normalization practice as illustrated in examples 1 and 2, but in this case, because the second functional dependency arises from the formula 
>
> ExtendedPrice = (Quantity * Price)
>
> , we reach a silly result. To see why, we follow the procedure in Figure 3-19 to create tables such that every determinant is a candidate key. This means that we move the columns Quantity, Price, and ExtendedPrice to tables of their own, as follows: 
>
> EXTENDED_PRICE (Quantity, Price, ExtendedPrice) 
>
> ORDER_ITEM_2 (OrderNumber, SKU, Quantity, Price) 
>
> Notice that we left both Quantity and Price in the original relation as a composite foreign key. These two tables are in BCNF, but the values in the EXTENDED_PRICE table are ridiculous. They are just the results of multiplying Quantity by Price. The simple fact is that we do not need to create a table to store these results. Instead, any time we need to know ExtendedPrice we will just compute it. In fact, we can define this formula to the DBMS and let the DBMS compute the value of ExtendedPrice when necessary. Using the formula, we can remove ExtendedPrice from the table. The resulting table is in BCNF:
>
> ORDER_ITEM_2 (OrderNumber, SKU, Quantity, Price) 
>
> Note that Quantity and Price are no longer foreign keys. The ORDER_ITEM_2 table with sample data now appears as shown in Figure 3-23.

现在考虑 Cape Codd 数据库的 ORDER _ item 关系，它的结构是: 

ORDER _ item (OrderNumber，SKU，Quantity，Price，ExtendedPrice)

具有函数依赖关系: 

(OrderNumber, SKU) → (Quantity, Price, ExtendedPrice)  

 (Quantity, Price) → ExtendedPrice 

这个表不满足 BCNF ，因为决定因素(Quantity，Price)不是候选键。 我们可以遵循示例1和2中所示的相同的标准化步骤，但是在这种情况下，由于第二个函数依赖来自于公式 

ExtendedPrice = (Quantity * Price) 

我们得到了一个不必要的结果。 为了查明原因，我们按照图3-19中的步骤创建表，使得每个决定因素都是一个候选键。 这意味着我们将 Quantity、 Price 和 ExtendedPrice 列移动到它们自己的表中，如下所示: 

EXTENDED _ Price (~~Quantity，Price~~，ExtendedPrice) 

ORDER _ item _ 2(~~OrderNumber，SKU~~，*Quantity*，*Price*)

注意，我们在原始关系中将 Quantity 和 Price 作为复合外键保留。 这两个表位于 BCNF 中，但 EXTENDED _ price 表中的值是荒谬的。 它们只是数量乘以价格的结果。 简单的事实是，**我们不需要创建一个表来存储这些结果**。 相反，任何时候我们需要知道 ExtendedPrice，我们只需要计算它。 实际上，我们可以在 DBMS 中定义这个公式，并在必要时让 DBMS 计算 ExtendedPrice 的值。 使用这个公式，我们可以从表中删除 ExtendedPrice。 由此产生的表满足 BCNF:

ORDER_ITEM_2 (~~OrderNumber, SKU~~, Quantity, Price) 

请注意，Quantity 和 Price 不再是外键。 现在，包含示例数据的 ORDER _ item _ 2表如图3-23所示。

<img src="%E6%95%B0%E6%8D%AE%E5%BA%93.assets/image-20200701211640865.png" alt="image-20200701211640865" style="zoom: 80%;" />

#### 标准化示例4

> Normalization example 4
>
> Consider the following table that stores data about student activities: STUDENT_ACTIVITY (StudentID, StudentName, Activity, ActivityFee, AmountPaid) where StudentID is a student identifier, StudentName is student name, Activity is the name of a club or other organized student activity, ActivityFee is the cost of joining the club or participating in the activity, and AmountPaid is the amount the student has paid toward the ActivityFee. Figure 3-24 shows sample data for this table. StudentID is a unique student identifier, so we know that: StudentID→ StudentName However, does the following functional dependency exist? 
>
> StudentID→Activity



考虑下表中存储学生活动的数据: 

STUDENT _ Activity (StudentID，StudentName，Activity，ActivityFee，AmountPaid) 

StudentID 是学生标识符，StudentName 是学生名称，Activity 是社团或其他有组织的学生活动的名称，ActivityFee 是加入社团或参加活动的成本，而 AmountPaid 是学生支付给 ActivityFee 的金额。 图3-24显示了此表的示例数据。 Studentid 是一个唯一的学生标识符，所以我们知道: 

StudentID → studename 

然而，是否存在下列函数依赖项？ 

StudentID→Activity

<img src="%E6%95%B0%E6%8D%AE%E5%BA%93.assets/image-20200701211845694.png" alt="image-20200701211845694" style="zoom:80%;" />

> It does if a student belongs to just one club or participates in just one activity,but it does not if a student belongs to more than one club or participates in more than one activity. Looking at the data, student Davis with StudentID 200 participates in both Skiing and Swimming, so StudentID does not determine Club. StudentID does not determine ActivityFee or AmountPaid, either. Now consider the StudentName column. Does StudentName determine StudentID? Is, for example, the value 'Jones' always paired with the same value of StudentID? No, there are two students named 'Jones', and they have different StudentID values. StudentName does not determine any other column in this table, either.
>
> Considering the next column, Activity, we know that many students can belong to a club. Therefore, Activity does not determine StudentID or StudentName. Does Activity determine ActivityFee? Is the value 'Skiing', for example, always paired with the same value of ActivityFee? From these data, it appears so, and using just this sample data, we can conclude that Activity determines ActivityFee. However, this data is just a sample. Logically, it is possible for students to pay different costs, perhaps because they select different levels of activity participation. If that were the case, then we would say that 
>
> (StudentID, Activity) → ActivityFee 
>
> To find out, we need to check with the users. Here, assume that all students pay the same fee for a given activity. The last column is AmountPaid, and it does not determine anything.

如果一个学生只参加了一个社团或者只参加了一项活动，那么它就是有效的，但是如果一个学生参加了不止一个社团或者参加了不止一项活动，那么它就不是有效的。 从数据来看，学生 Davis （学生id=200）同时参加了滑雪和游泳，所以学生并不能决定社团。 也不确定 ActivityFee 或 AmountPaid。 现在考虑 StudentName 列。 StudentName决定StudentID吗？ 例如，Jones总是对应 StudentID 的相同值吗？ 不，有两个学生叫Jones，他们有不同的StudentID。 Studentname 也不确定该表中的任何其他列。

考虑到下一个列：活动，我们知道许多学生可以加入一个社团。 因此，活动不决定StudentID或StudentNAME。 活动是否决定活动收费？ 例如，“ Skiing”的值总是对应 ActivityFee 的相同值吗？ 从这些数据来看，似乎是这样的，仅仅使用这些示例数据，我们就可以得出结论: Activity 决定 ActivityFee。 然而，这些数据只是一个样本。 从逻辑上讲，学生支付不同的费用是可能的，也许是因为他们选择了不同程度的活动参与。 如果是这样的话，那么我们会说

(StudentID，Activity)→ ActivityFee 

要找到答案，我们需要检查用户。 在这里，假设所有的学生为一个给定的活动支付相同的费用。 最后一列是 AmountPaid，它不确定任何内容。

> So far, we have two functional dependencies: 
>
> StudentID → StudentName 
>
> Activity→ ActivityFee 
>
> Are there other functional dependencies with composite determinants? No single column determines AmountPaid, so consider possible composite determinants for it. AmountPaid is dependent on both the student and the club the student has joined. Therefore, it is determined by the combination of the determinants StudentID and Activity. Thus, we can say 
>
> (StudentID, Activity) →AmountPaid 
>
> So far we have three determinants: StudentID, Activity, and (StudentID, Activity). Are any of these candidate keys? Do any of these determinants identify a unique row? From the data, it appears that (StudentID, Activity) identifies a unique row and is a candidate key. Again, in real situations, we would need to check out this assumption with the users. STUDENT_ACTIVITY_PAYMENT is not in BCNF because columns StudentID and Activity are both determinants, but neither is a candidate key. StudentID and Activity are only part of the candidate key (StudentID, Activity).
>
> By The Way Both StudentID and Activity are part of the candidate key (StudentID, Activity). This, however, is not good enough. A determinant must have all of the same columns to be the same as a candidate key. Remember, as we stated above: I swear to construct my tables so that all non-key columns are dependent on the key, the whole key, and nothing but the key, so help me Codd!

到目前为止，我们有两个函数依赖: 

StudentID → StudentName 

Activity → ActivityFee 

复合决定因素还有其他函数依赖吗？ **没有单个列可以确定 AmountPaid，因此要考虑其可能的复合列**。 Amountpaid 取决于学生和学生参加的社团。 因此，它是由StudentID 和 Activity联合决定的。 因此，我们可以得出:

(StudentID，Activity)→ AmountPaid 

到目前为止，我们有三个决定因素: StudentID，Activity 和(StudentID，Activity)。 这些是候选键吗？ 这些决定因素中是否能确定了一个唯一的行？ 从数据中可以看出(StudentID，Activity)可以决定一个唯一的行，并且是一个候选键。 同样，在实际情况中，我们需要与用户一起检查这个假设。 因为列 StudentID 和 Activity 都是决定因素，但是两者都不是候选键，所以 STUDENT _ Activity _ payment 不满足 BCNF 。 Studentid 和 Activity 只是候选关键字(StudentID，Activity)的一部分。

顺便说一下，学习和活动都是候选关键词(StudentID, Activity)的一部分。 然而，这还不够好。 **决定因素必须与候选键在所有列都完全一致**。 记住，正如我们上面所说的: 我庄严发誓，我在建表过程中，所有非键属性都依赖于键，无他，只有整个键，所以 Codd 大神，请保佑我！

> To normalize this table, we need to construct tables so that every determinant is a candidate key. We can do this by creating a separate table for each functional dependency as we did before. The result is: 
>
> STUDENT (StudentID, StudentName) 
>
> ACTIVITY (Activity, ActivityFee) 
>
> PAYMENT (StudentID, Activity, AmountPaid) 
>
> with referential integrity constraints: PAYMENT.StudentID must exist in STUDENT.StudentID and PAYMENT.Activity must exist in ACTIVITY.Activity These tables are in BCNF and will have no anomalies from functional dependencies. The sample data for the normalized tables are shown in Figure 3-25.

为了规范化这个表，我们需要构造表，**使每个决定因素都是一个候选键**。 我们可以像前面那样为每个函数依赖项创建一个单独的表。 结果是:

STUDENT (StudentID, StudentName)   

ACTIVITY (Activity, ActivityFee)   

PAYMENT (StudentID, Activity, AmountPaid) 

受参照完整性约束: PAYMENT.StudentID必须存在于STUDENT.StudentID中，PAYMENT.Activity必须存在于ACTIVITY.Activity中。 这些表格满足 BCNF ，不会出现函数依赖性的异常。 经过规范化后，表的示例数据如图3-25所示。

<img src="%E6%95%B0%E6%8D%AE%E5%BA%93.assets/image-20200701212058755.png" alt="image-20200701212058755" style="zoom: 80%;" />

#### 标准化示例5

> Normalization example 5 
>
> Now consider a normalization process that requires two iterations of step 3 in the procedure in Figure 3-19. To do this, we will extend the SKU_DATA relation by adding the budget code of each department. We call the revised relation SKU_DATA_3 and define it as follows: 
>
> SKU_DATA_3 (SKU, SKU_Description, Department, DeptBudgetCode, Buyer) 
>
> Sample data for this relation are shown in Figure 3-26. SKU_DATA_3 has the following functional dependencies:
>
> SKU → (SKU_Description, Department, DeptBudgetCode, Buyer) 
>
> SKU_Description → (SKU, Department, DeptBudgetCode, Buyer) 
>
> Buyer → (Department, DeptBudgetCode) 
>
> Department → DeptBudgetCode 
>
> DeptBudgetCode → Department 
>
> Of the five determinants, both SKU and SKU_Description are candidate keys, but Buyer, Department and DeptBudgetCode are not candidate keys. Therefore, this relation is not in BCNF.

现在考虑一个标准化过程，该过程需要在图3-19中的过程中两次执行步骤3。 为此，我们将通过添加各部门的budget code来扩展 SKU _ data 关系。 我们称这个修正关系为 SKU _ data _ 3，并将它定义为: 

SKU_DATA_3 (SKU, SKU_Description, Department, DeptBudgetCode, Buyer) 

此关系的示例数据如图3-26所示。 SKU _ data _ 3具有以下函数依赖关系:

SKU → (SKU_Description, Department, DeptBudgetCode, Buyer)   

SKU_Description → (SKU, Department, DeptBudgetCode, Buyer)   

Buyer → (Department, DeptBudgetCode)   

Department → DeptBudgetCode   DeptBudgetCode → Department 

在这五个决定因素中，SKU 和 SKU _ description 都是候选关键，但Buyer, Department , DeptBudgetCode 不是候选关键。 因此，这种关系不满足 BCNF 。

<img src="%E6%95%B0%E6%8D%AE%E5%BA%93.assets/image-20200701221702356.png" alt="image-20200701221702356" style="zoom:80%;" />

>  To normalize this table, we must transform this table into two or more tables that are in BCNF. In this case, there are two problematic functional dependencies. According to the note at the end of the procedure in Figure 3-19, we take the functional dependency whose determinant is not a candidate key and has the largest number of columns first. In this case, we take the columns of
>
> Buyer → (Department, DeptBudgetCode) and place them in a table of their own. Next, we make the determinant the primary key of the new table, remove all columns except Buyer from SKU_DATA_3, and make Buyer a foreign key of the new version of SKU_DATA_3, which we will name SKU_DATA_4. We can also now assign SKU as the primary key of SKU_DATA_4. The results are: BUYER (Buyer, Department, DeptBudgetCode) SKU_DATA_4 (SKU, SKU_Description, Buyer) We also create the referential integrity constraint: SKU_DATA_4.Buyer must exist in BUYER.Buyer The functional dependencies from SKU_DATA_4 are: SKU → (SKU_Description, Buyer) SKU_Description→ (SKU, Buyer)



## 4.4 寻找函数依赖



## 4.5 规范化问题举例



## 4.6 多值依赖与DK范式



## 4.7 小结





# 第五章：用规范化理论完成数据库设计







